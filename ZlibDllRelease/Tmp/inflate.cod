; Listing generated by Microsoft (R) Optimizing Compiler Version 19.39.33321.0 

	TITLE	c:\users\pichau\documents\boldergarte\softwares\libraries\downloads\zlib\zlib-develop\zlib-develop\contrib\vstudio\vc17\x86\zlibdllrelease\tmp\inflate.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BH@LIBMMIGA@incorrect?5header?5check@	; `string'
PUBLIC	??_C@_0BL@IHKGDAEE@unknown?5compression?5method@ ; `string'
PUBLIC	??_C@_0BE@EMOGCLGO@invalid?5window?5size@	; `string'
PUBLIC	??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@	; `string'
PUBLIC	??_C@_0BE@GONKLEPM@header?5crc?5mismatch@	; `string'
PUBLIC	??_C@_0BF@MEIGEHBE@incorrect?5data?5check@	; `string'
PUBLIC	??_C@_0BH@FGKKJGOC@incorrect?5length?5check@	; `string'
;	COMDAT ??_C@_0BH@FGKKJGOC@incorrect?5length?5check@
CONST	SEGMENT
??_C@_0BH@FGKKJGOC@incorrect?5length?5check@ DB 'incorrect length check', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MEIGEHBE@incorrect?5data?5check@
CONST	SEGMENT
??_C@_0BF@MEIGEHBE@incorrect?5data?5check@ DB 'incorrect data check', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GONKLEPM@header?5crc?5mismatch@
CONST	SEGMENT
??_C@_0BE@GONKLEPM@header?5crc?5mismatch@ DB 'header crc mismatch', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@
CONST	SEGMENT
??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@ DB 'unknown header flags '
	DB	'set', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EMOGCLGO@invalid?5window?5size@
CONST	SEGMENT
??_C@_0BE@EMOGCLGO@invalid?5window?5size@ DB 'invalid window size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IHKGDAEE@unknown?5compression?5method@
CONST	SEGMENT
??_C@_0BL@IHKGDAEE@unknown?5compression?5method@ DB 'unknown compression '
	DB	'method', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LIBMMIGA@incorrect?5header?5check@
CONST	SEGMENT
??_C@_0BH@LIBMMIGA@incorrect?5header?5check@ DB 'incorrect header check', 00H ; `string'
	ORG $+2
?lenfix@?1??fixedtables@@9@9 DB 060H			; `fixedtables'::`2'::lenfix
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c0H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a0H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e0H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	090H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d0H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b0H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f0H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c8H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a8H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e8H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	098H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d8H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b8H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f8H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c4H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a4H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e4H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	094H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d4H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b4H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f4H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0ccH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0acH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0ecH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09cH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0dcH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bcH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fcH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c2H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a2H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e2H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	092H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d2H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b2H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f2H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0caH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0aaH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0eaH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09aH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0daH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0baH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0faH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c6H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a6H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e6H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	096H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d6H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b6H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f6H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0ceH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0aeH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0eeH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09eH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0deH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0beH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0feH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c1H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a1H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e1H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	091H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d1H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b1H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f1H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c9H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a9H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e9H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	099H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d9H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b9H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f9H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c5H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a5H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e5H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	095H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d5H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b5H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f5H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0cdH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0adH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0edH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09dH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0ddH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bdH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fdH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c3H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a3H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e3H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	093H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d3H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b3H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f3H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0cbH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0abH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0ebH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09bH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0dbH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0bbH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0fbH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c7H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a7H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e7H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	097H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d7H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b7H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f7H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0cfH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0afH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0efH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09fH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0dfH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0bfH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0ffH
?distfix@?1??fixedtables@@9@9 DB 010H			; `fixedtables'::`2'::distfix
	DB	05H
	DW	01H
	DB	017H
	DB	05H
	DW	0101H
	DB	013H
	DB	05H
	DW	011H
	DB	01bH
	DB	05H
	DW	01001H
	DB	011H
	DB	05H
	DW	05H
	DB	019H
	DB	05H
	DW	0401H
	DB	015H
	DB	05H
	DW	041H
	DB	01dH
	DB	05H
	DW	04001H
	DB	010H
	DB	05H
	DW	03H
	DB	018H
	DB	05H
	DW	0201H
	DB	014H
	DB	05H
	DW	021H
	DB	01cH
	DB	05H
	DW	02001H
	DB	012H
	DB	05H
	DW	09H
	DB	01aH
	DB	05H
	DW	0801H
	DB	016H
	DB	05H
	DW	081H
	DB	040H
	DB	05H
	DW	00H
	DB	010H
	DB	05H
	DW	02H
	DB	017H
	DB	05H
	DW	0181H
	DB	013H
	DB	05H
	DW	019H
	DB	01bH
	DB	05H
	DW	01801H
	DB	011H
	DB	05H
	DW	07H
	DB	019H
	DB	05H
	DW	0601H
	DB	015H
	DB	05H
	DW	061H
	DB	01dH
	DB	05H
	DW	06001H
	DB	010H
	DB	05H
	DW	04H
	DB	018H
	DB	05H
	DW	0301H
	DB	014H
	DB	05H
	DW	031H
	DB	01cH
	DB	05H
	DW	03001H
	DB	012H
	DB	05H
	DW	0dH
	DB	01aH
	DB	05H
	DW	0c01H
	DB	016H
	DB	05H
	DW	0c1H
	DB	040H
	DB	05H
	DW	00H
?order@?1??inflate@@9@9 DW 010H				; `inflate'::`2'::order
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
PUBLIC	_inflateCodesUsed@4
PUBLIC	_inflateMark@4
PUBLIC	_inflateValidate@8
PUBLIC	_inflateUndermine@8
PUBLIC	_inflateCopy@8
PUBLIC	_inflateSyncPoint@4
PUBLIC	_inflateSync@4
PUBLIC	_inflateGetHeader@8
PUBLIC	_inflateSetDictionary@12
PUBLIC	_inflateGetDictionary@12
PUBLIC	_inflatePrime@12
PUBLIC	_inflateInit_@12
PUBLIC	_inflateReset2@8
PUBLIC	_inflateResetKeep@4
PUBLIC	_inflateEnd@4
PUBLIC	_inflate@8
PUBLIC	_inflateInit2_@16
PUBLIC	_inflateReset@4
; Function compile flags: /Ogtp
; File C:\Users\Pichau\Documents\Boldergarte\Softwares\LIBRARIES\downloads\zlib\zlib-develop\zlib-develop\inflate.c
;	COMDAT _inflateReset@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateReset@4 PROC					; COMDAT

; 130  : int ZEXPORT inflateReset(z_streamp strm) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 131  :     struct inflate_state FAR *state;
; 132  : 
; 133  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 09		 je	 SHORT $LN2@inflateRes
  0000f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 139  : }

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
$LN2@inflateRes:

; 134  :     state = (struct inflate_state FAR *)strm->state;

  00018	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]

; 135  :     state->wsize = 0;
; 136  :     state->whave = 0;
; 137  :     state->wnext = 0;
; 138  :     return inflateResetKeep(strm);

  0001b	89 4d 08	 mov	 DWORD PTR _strm$[ebp], ecx
  0001e	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], 0
  00025	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], 0
  0002c	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [eax+52], 0

; 139  : }

  00033	5d		 pop	 ebp

; 135  :     state->wsize = 0;
; 136  :     state->whave = 0;
; 137  :     state->wnext = 0;
; 138  :     return inflateResetKeep(strm);

  00034	e9 00 00 00 00	 jmp	 _inflateResetKeep@4
_inflateReset@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\Pichau\Documents\Boldergarte\Softwares\LIBRARIES\downloads\zlib\zlib-develop\zlib-develop\inflate.c
;	COMDAT _inflateInit2_@16
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_windowBits$ = 12					; size = 4
_version$ = 16						; size = 4
_stream_size$ = 20					; size = 4
_inflateInit2_@16 PROC					; COMDAT

; 179  :                           const char *version, int stream_size) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 180  :     int ret;
; 181  :     struct inflate_state FAR *state;
; 182  : 
; 183  :     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||

  00003	8b 45 10	 mov	 eax, DWORD PTR _version$[ebp]
  00006	56		 push	 esi
  00007	8b 75 08	 mov	 esi, DWORD PTR _strm$[ebp]
  0000a	85 c0		 test	 eax, eax
  0000c	0f 84 ac 00 00
	00		 je	 $LN3@inflateIni
  00012	80 38 31	 cmp	 BYTE PTR [eax], 49	; 00000031H
  00015	0f 85 a3 00 00
	00		 jne	 $LN3@inflateIni
  0001b	83 7d 14 38	 cmp	 DWORD PTR _stream_size$[ebp], 56 ; 00000038H
  0001f	0f 85 99 00 00
	00		 jne	 $LN3@inflateIni

; 186  :     if (strm == Z_NULL) return Z_STREAM_ERROR;

  00025	85 f6		 test	 esi, esi
  00027	75 08		 jne	 SHORT $LN4@inflateIni
  00029	8d 46 fe	 lea	 eax, DWORD PTR [esi-2]
  0002c	5e		 pop	 esi

; 216  : }

  0002d	5d		 pop	 ebp
  0002e	c2 10 00	 ret	 16			; 00000010H
$LN4@inflateIni:

; 187  :     strm->msg = Z_NULL;                 /* in case we return an error */
; 188  :     if (strm->zalloc == (alloc_func)0) {

  00031	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00034	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
  0003b	85 c0		 test	 eax, eax
  0003d	75 13		 jne	 SHORT $LN10@inflateIni

; 189  : #ifdef Z_SOLO
; 190  :         return Z_STREAM_ERROR;
; 191  : #else
; 192  :         strm->zalloc = zcalloc;
; 193  :         strm->opaque = (voidpf)0;

  0003f	89 46 28	 mov	 DWORD PTR [esi+40], eax
  00042	33 c9		 xor	 ecx, ecx
  00044	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], OFFSET _zcalloc
  0004b	b8 00 00 00 00	 mov	 eax, OFFSET _zcalloc
  00050	eb 03		 jmp	 SHORT $LN5@inflateIni
$LN10@inflateIni:
  00052	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
$LN5@inflateIni:

; 194  : #endif
; 195  :     }
; 196  :     if (strm->zfree == (free_func)0)

  00055	83 7e 24 00	 cmp	 DWORD PTR [esi+36], 0
  00059	75 07		 jne	 SHORT $LN6@inflateIni

; 197  : #ifdef Z_SOLO
; 198  :         return Z_STREAM_ERROR;
; 199  : #else
; 200  :         strm->zfree = zcfree;

  0005b	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], OFFSET _zcfree
$LN6@inflateIni:
  00062	57		 push	 edi

; 201  : #endif
; 202  :     state = (struct inflate_state FAR *)

  00063	68 d0 1b 00 00	 push	 7120			; 00001bd0H
  00068	6a 01		 push	 1
  0006a	51		 push	 ecx
  0006b	ff d0		 call	 eax
  0006d	8b f8		 mov	 edi, eax
  0006f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 203  :             ZALLOC(strm, 1, sizeof(struct inflate_state));
; 204  :     if (state == Z_NULL) return Z_MEM_ERROR;

  00072	85 ff		 test	 edi, edi
  00074	75 09		 jne	 SHORT $LN7@inflateIni
  00076	8d 47 fc	 lea	 eax, DWORD PTR [edi-4]
  00079	5f		 pop	 edi
  0007a	5e		 pop	 esi

; 216  : }

  0007b	5d		 pop	 ebp
  0007c	c2 10 00	 ret	 16			; 00000010H
$LN7@inflateIni:
  0007f	53		 push	 ebx

; 205  :     Tracev((stderr, "inflate: allocated\n"));
; 206  :     strm->state = (struct internal_state FAR *)state;
; 207  :     state->strm = strm;
; 208  :     state->window = Z_NULL;
; 209  :     state->mode = HEAD;     /* to pass state test in inflateReset2() */
; 210  :     ret = inflateReset2(strm, windowBits);

  00080	ff 75 0c	 push	 DWORD PTR _windowBits$[ebp]
  00083	89 7e 1c	 mov	 DWORD PTR [esi+28], edi
  00086	56		 push	 esi
  00087	89 37		 mov	 DWORD PTR [edi], esi
  00089	c7 47 38 00 00
	00 00		 mov	 DWORD PTR [edi+56], 0
  00090	c7 47 04 34 3f
	00 00		 mov	 DWORD PTR [edi+4], 16180 ; 00003f34H
  00097	e8 00 00 00 00	 call	 _inflateReset2@8
  0009c	8b d8		 mov	 ebx, eax

; 211  :     if (ret != Z_OK) {

  0009e	85 db		 test	 ebx, ebx
  000a0	74 13		 je	 SHORT $LN8@inflateIni

; 212  :         ZFREE(strm, state);

  000a2	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  000a5	57		 push	 edi
  000a6	ff 76 28	 push	 DWORD PTR [esi+40]
  000a9	ff d1		 call	 ecx
  000ab	83 c4 08	 add	 esp, 8

; 213  :         strm->state = Z_NULL;

  000ae	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0
$LN8@inflateIni:

; 214  :     }
; 215  :     return ret;

  000b5	8b c3		 mov	 eax, ebx
  000b7	5b		 pop	 ebx
  000b8	5f		 pop	 edi
  000b9	5e		 pop	 esi

; 216  : }

  000ba	5d		 pop	 ebp
  000bb	c2 10 00	 ret	 16			; 00000010H
$LN3@inflateIni:

; 184  :         stream_size != (int)(sizeof(z_stream)))
; 185  :         return Z_VERSION_ERROR;

  000be	b8 fa ff ff ff	 mov	 eax, -6			; fffffffaH
  000c3	5e		 pop	 esi

; 216  : }

  000c4	5d		 pop	 ebp
  000c5	c2 10 00	 ret	 16			; 00000010H
_inflateInit2_@16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\Pichau\Documents\Boldergarte\Softwares\LIBRARIES\downloads\zlib\zlib-develop\zlib-develop\inflate.c
;	COMDAT _inflate@8
_TEXT	SEGMENT
$T1 = -68						; size = 4
tv5163 = -68						; size = 4
tv5161 = -68						; size = 4
tv4996 = -68						; size = 4
tv4969 = -68						; size = 4
tv4967 = -68						; size = 4
tv4965 = -68						; size = 4
tv4963 = -68						; size = 4
tv4952 = -68						; size = 4
tv4951 = -68						; size = 4
tv4944 = -68						; size = 4
_copy$5$ = -68						; size = 4
_copy$3$ = -68						; size = 4
_copy$2$ = -68						; size = 4
_copy$1$ = -68						; size = 4
_in$1$ = -64						; size = 4
$T2 = -60						; size = 4
$T3 = -56						; size = 4
$T4 = -56						; size = 4
$T5 = -56						; size = 4
$T6 = -56						; size = 4
$T7 = -56						; size = 4
$T8 = -56						; size = 4
$T9 = -56						; size = 4
tv5005 = -56						; size = 4
tv4968 = -56						; size = 4
tv4945 = -56						; size = 4
_copy$7$ = -56						; size = 4
$T10 = -56						; size = 4
_last$ = -56						; size = 4
$T11 = -52						; size = 4
$T12 = -52						; size = 4
$T13 = -52						; size = 4
_from$1$ = -52						; size = 4
tv4943 = -52						; size = 4
tv4686 = -52						; size = 4
_copy$6$ = -52						; size = 4
_len$1$ = -52						; size = 4
_ret$1$ = -48						; size = 4
$T14 = -44						; size = 4
$T15 = -44						; size = 4
$T16 = -44						; size = 4
_copy$10$ = -44						; size = 4
tv4751 = -44						; size = 4
tv4741 = -44						; size = 4
_copy$8$ = -44						; size = 4
_len$2$ = -44						; size = 4
_out$1$ = -40						; size = 4
_put$1$ = -36						; size = 4
_hbuf$ = -32						; size = 4
_left$1$ = -28						; size = 4
_bits$1$ = -24						; size = 4
_next$1$ = -20						; size = 4
_state$1$ = -16						; size = 4
_have$1$ = -12						; size = 4
_hold$1$ = -8						; size = 4
tv5104 = -1						; size = 1
tv5103 = -1						; size = 1
tv4931 = 8						; size = 4
_strm$ = 8						; size = 4
_flush$ = 12						; size = 4
_inflate@8 PROC						; COMDAT

; 590  : int ZEXPORT inflate(z_streamp strm, int flush) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx

; 591  :     struct inflate_state FAR *state;
; 592  :     z_const unsigned char FAR *next;    /* next input */
; 593  :     unsigned char FAR *put;     /* next output */
; 594  :     unsigned have, left;        /* available input and output */
; 595  :     unsigned long hold;         /* bit buffer */
; 596  :     unsigned bits;              /* bits in bit buffer */
; 597  :     unsigned in, out;           /* save starting available input and output */
; 598  :     unsigned copy;              /* number of stored or match bytes to copy */
; 599  :     unsigned char FAR *from;    /* where to copy match bytes from */
; 600  :     code here;                  /* current decoding table entry */
; 601  :     code last;                  /* parent table entry */
; 602  :     unsigned len;               /* length to copy for repeats, bits to drop */
; 603  :     int ret;                    /* return code */
; 604  : #ifdef GUNZIP
; 605  :     unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
; 606  : #endif
; 607  :     static const unsigned short order[19] = /* permutation of code lengths */
; 608  :         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
; 609  : 
; 610  :     if (inflateStateCheck(strm) || strm->next_out == Z_NULL ||

  00007	8b 5d 08	 mov	 ebx, DWORD PTR _strm$[ebp]
  0000a	8b cb		 mov	 ecx, ebx
  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	e8 00 00 00 00	 call	 _inflateStateCheck
  00013	85 c0		 test	 eax, eax
  00015	0f 85 8c 15 00
	00		 jne	 $LN333@inflate
  0001b	83 7b 0c 00	 cmp	 DWORD PTR [ebx+12], 0
  0001f	8d 43 0c	 lea	 eax, DWORD PTR [ebx+12]
  00022	0f 84 7f 15 00
	00		 je	 $LN333@inflate
  00028	83 3b 00	 cmp	 DWORD PTR [ebx], 0
  0002b	75 0f		 jne	 SHORT $LN721@inflate
  0002d	83 7b 04 00	 cmp	 DWORD PTR [ebx+4], 0
  00031	0f 85 70 15 00
	00		 jne	 $LN333@inflate
  00037	8d 73 0c	 lea	 esi, DWORD PTR [ebx+12]
  0003a	eb 02		 jmp	 SHORT $LN653@inflate
$LN721@inflate:
  0003c	8b f0		 mov	 esi, eax
$LN653@inflate:

; 611  :         (strm->next_in == Z_NULL && strm->avail_in != 0))
; 612  :         return Z_STREAM_ERROR;
; 613  : 
; 614  :     state = (struct inflate_state FAR *)strm->state;

  0003e	8b 4b 1c	 mov	 ecx, DWORD PTR [ebx+28]
  00041	89 4d f0	 mov	 DWORD PTR _state$1$[ebp], ecx

; 615  :     if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */

  00044	89 45 c4	 mov	 DWORD PTR $T2[ebp], eax
  00047	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0004a	89 55 c8	 mov	 DWORD PTR $T8[ebp], edx
  0004d	81 fa 3f 3f 00
	00		 cmp	 edx, 16191		; 00003f3fH
  00053	75 11		 jne	 SHORT $LN4@inflate
  00055	c7 41 04 40 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16192 ; 00003f40H
  0005c	c7 45 c8 40 3f
	00 00		 mov	 DWORD PTR $T8[ebp], 16192 ; 00003f40H
  00063	89 75 c4	 mov	 DWORD PTR $T2[ebp], esi
$LN4@inflate:

; 616  :     LOAD();

  00066	8b 00		 mov	 eax, DWORD PTR [eax]
  00068	8b 3b		 mov	 edi, DWORD PTR [ebx]
  0006a	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  0006d	8b 71 40	 mov	 esi, DWORD PTR [ecx+64]
  00070	89 45 dc	 mov	 DWORD PTR _put$1$[ebp], eax
  00073	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  00076	8b 5b 04	 mov	 ebx, DWORD PTR [ebx+4]
  00079	89 45 e4	 mov	 DWORD PTR _left$1$[ebp], eax

; 617  :     in = have;
; 618  :     out = left;

  0007c	89 45 d8	 mov	 DWORD PTR _out$1$[ebp], eax

; 619  :     ret = Z_OK;

  0007f	33 c0		 xor	 eax, eax
  00081	89 45 d0	 mov	 DWORD PTR _ret$1$[ebp], eax

; 620  :     for (;;)
; 621  :         switch (state->mode) {

  00084	8b 45 c8	 mov	 eax, DWORD PTR $T8[ebp]
  00087	05 cc c0 ff ff	 add	 eax, -16180		; ffffc0ccH
  0008c	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  0008f	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00092	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00095	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  00098	89 5d c0	 mov	 DWORD PTR _in$1$[ebp], ebx
  0009b	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0009e	0f 87 03 15 00
	00		 ja	 $LN333@inflate
$LL5@inflate:
  000a4	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN787@inflate[eax*4]
$LN335@inflate:

; 622  :         case HEAD:
; 623  :             if (state->wrap == 0) {

  000ab	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  000af	75 0c		 jne	 SHORT $LN12@inflate

; 624  :                 state->mode = TYPEDO;

  000b1	c7 41 04 40 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16192 ; 00003f40H

; 625  :                 break;

  000b8	e9 d9 14 00 00	 jmp	 $LN8@inflate
$LN12@inflate:

; 626  :             }
; 627  :             NEEDBITS(16);

  000bd	83 fe 10	 cmp	 esi, 16			; 00000010H
  000c0	73 2a		 jae	 SHORT $LN10@inflate
$LL13@inflate:
  000c2	85 db		 test	 ebx, ebx
  000c4	0f 84 10 05 00
	00		 je	 $LN905@inflate
  000ca	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  000cd	8b ce		 mov	 ecx, esi
  000cf	d3 e0		 shl	 eax, cl
  000d1	83 c6 08	 add	 esi, 8
  000d4	4b		 dec	 ebx
  000d5	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  000d8	03 d0		 add	 edx, eax
  000da	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  000dd	47		 inc	 edi
  000de	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  000e1	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  000e4	83 fe 10	 cmp	 esi, 16			; 00000010H
  000e7	72 d9		 jb	 SHORT $LL13@inflate
  000e9	8b 4d f0	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN10@inflate:

; 628  : #ifdef GUNZIP
; 629  :             if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */

  000ec	f6 41 0c 02	 test	 BYTE PTR [ecx+12], 2
  000f0	74 5a		 je	 SHORT $LN338@inflate
  000f2	81 fa 1f 8b 00
	00		 cmp	 edx, 35615		; 00008b1fH
  000f8	75 52		 jne	 SHORT $LN338@inflate

; 630  :                 if (state->wbits == 0)

  000fa	83 79 28 00	 cmp	 DWORD PTR [ecx+40], 0
  000fe	75 07		 jne	 SHORT $LN339@inflate

; 631  :                     state->wbits = 15;

  00100	c7 41 28 0f 00
	00 00		 mov	 DWORD PTR [ecx+40], 15	; 0000000fH
$LN339@inflate:

; 632  :                 state->check = crc32(0L, Z_NULL, 0);

  00107	6a 00		 push	 0
  00109	6a 00		 push	 0
  0010b	6a 00		 push	 0
  0010d	e8 00 00 00 00	 call	 _crc32@12
  00112	8b 4d f0	 mov	 ecx, DWORD PTR _state$1$[ebp]

; 633  :                 CRC2(state->check, hold);

  00115	6a 02		 push	 2
  00117	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  0011a	8b 4d f8	 mov	 ecx, DWORD PTR _hold$1$[ebp]
  0011d	88 4d e0	 mov	 BYTE PTR _hbuf$[ebp], cl
  00120	c1 e9 08	 shr	 ecx, 8
  00123	88 4d e1	 mov	 BYTE PTR _hbuf$[ebp+1], cl
  00126	8d 4d e0	 lea	 ecx, DWORD PTR _hbuf$[ebp]
  00129	51		 push	 ecx
  0012a	50		 push	 eax
  0012b	e8 00 00 00 00	 call	 _crc32@12
  00130	8b 4d f0	 mov	 ecx, DWORD PTR _state$1$[ebp]

; 634  :                 INITBITS();

  00133	33 d2		 xor	 edx, edx
  00135	33 f6		 xor	 esi, esi
  00137	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  0013a	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  0013d	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 635  :                 state->mode = FLAGS;

  00140	c7 41 04 35 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16181 ; 00003f35H

; 636  :                 break;

  00147	e9 4a 14 00 00	 jmp	 $LN8@inflate
$LN338@inflate:

; 637  :             }
; 638  :             if (state->head != Z_NULL)

  0014c	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  0014f	85 c0		 test	 eax, eax
  00151	74 07		 je	 SHORT $LN340@inflate

; 639  :                 state->head->done = -1;

  00153	c7 40 30 ff ff
	ff ff		 mov	 DWORD PTR [eax+48], -1
$LN340@inflate:

; 640  :             if (!(state->wrap & 1) ||   /* check if zlib header allowed */

  0015a	f6 41 0c 01	 test	 BYTE PTR [ecx+12], 1
  0015e	0f 84 cf 00 00
	00		 je	 $LN342@inflate
  00164	0f b6 ca	 movzx	 ecx, dl
  00167	8b c2		 mov	 eax, edx
  00169	c1 e1 08	 shl	 ecx, 8
  0016c	33 d2		 xor	 edx, edx
  0016e	c1 e8 08	 shr	 eax, 8
  00171	03 c1		 add	 eax, ecx
  00173	b9 1f 00 00 00	 mov	 ecx, 31			; 0000001fH
  00178	f7 f1		 div	 ecx
  0017a	8b 4d f0	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0017d	85 d2		 test	 edx, edx
  0017f	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00182	0f 85 ab 00 00
	00		 jne	 $LN342@inflate

; 648  :             }
; 649  :             if (BITS(4) != Z_DEFLATED) {

  00188	8b c2		 mov	 eax, edx
  0018a	24 0f		 and	 al, 15			; 0000000fH
  0018c	3c 08		 cmp	 al, 8
  0018e	74 0f		 je	 SHORT $LN26@inflate

; 650  :                 strm->msg = (char *)"unknown compression method";

  00190	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00193	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BL@IHKGDAEE@unknown?5compression?5method@

; 651  :                 state->mode = BAD;
; 652  :                 break;

  0019a	e9 f0 13 00 00	 jmp	 $LN1111@inflate
$LN26@inflate:

; 653  :             }
; 654  :             DROPBITS(4);
; 655  :             len = BITS(4) + 8;
; 656  :             if (state->wbits == 0)

  0019f	8b 79 28	 mov	 edi, DWORD PTR [ecx+40]
  001a2	83 ee 04	 sub	 esi, 4
  001a5	c1 ea 04	 shr	 edx, 4
  001a8	8b c2		 mov	 eax, edx
  001aa	89 7d c8	 mov	 DWORD PTR $T7[ebp], edi
  001ad	83 e0 0f	 and	 eax, 15			; 0000000fH
  001b0	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  001b3	83 c0 08	 add	 eax, 8
  001b6	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  001b9	85 ff		 test	 edi, edi
  001bb	89 45 cc	 mov	 DWORD PTR _len$1$[ebp], eax
  001be	8b 7d ec	 mov	 edi, DWORD PTR _next$1$[ebp]
  001c1	75 06		 jne	 SHORT $LN344@inflate

; 657  :                 state->wbits = len;

  001c3	89 41 28	 mov	 DWORD PTR [ecx+40], eax
  001c6	89 45 c8	 mov	 DWORD PTR $T7[ebp], eax
$LN344@inflate:

; 658  :             if (len > 15 || len > state->wbits) {

  001c9	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  001cc	77 56		 ja	 SHORT $LN346@inflate
  001ce	3b 45 c8	 cmp	 eax, DWORD PTR $T7[ebp]
  001d1	77 51		 ja	 SHORT $LN346@inflate

; 662  :             }
; 663  :             state->dmax = 1U << len;

  001d3	8b 4d cc	 mov	 ecx, DWORD PTR _len$1$[ebp]
  001d6	b8 01 00 00 00	 mov	 eax, 1
  001db	d3 e0		 shl	 eax, cl
  001dd	8b 4d f0	 mov	 ecx, DWORD PTR _state$1$[ebp]

; 664  :             state->flags = 0;               /* indicate zlib header */
; 665  :             Tracev((stderr, "inflate:   zlib header ok\n"));
; 666  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  001e0	6a 00		 push	 0
  001e2	6a 00		 push	 0
  001e4	6a 00		 push	 0
  001e6	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  001e9	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  001f0	e8 00 00 00 00	 call	 _adler32@12
  001f5	8b 4d f0	 mov	 ecx, DWORD PTR _state$1$[ebp]
  001f8	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  001fb	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  001fe	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 667  :             state->mode = hold & 0x200 ? DICTID : TYPE;

  00201	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00204	c1 ea 08	 shr	 edx, 8
  00207	f7 d2		 not	 edx
  00209	83 e2 02	 and	 edx, 2
  0020c	81 ca 3d 3f 00
	00		 or	 edx, 16189		; 00003f3dH
  00212	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 668  :             INITBITS();

  00215	33 d2		 xor	 edx, edx
  00217	33 f6		 xor	 esi, esi
  00219	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  0021c	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi

; 669  :             break;

  0021f	e9 72 13 00 00	 jmp	 $LN8@inflate
$LN346@inflate:

; 659  :                 strm->msg = (char *)"invalid window size";

  00224	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00227	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BE@EMOGCLGO@invalid?5window?5size@

; 660  :                 state->mode = BAD;
; 661  :                 break;

  0022e	e9 5c 13 00 00	 jmp	 $LN1111@inflate
$LN342@inflate:

; 641  : #else
; 642  :             if (
; 643  : #endif
; 644  :                 ((BITS(8) << 8) + (hold >> 8)) % 31) {
; 645  :                 strm->msg = (char *)"incorrect header check";

  00233	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00236	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BH@LIBMMIGA@incorrect?5header?5check@

; 646  :                 state->mode = BAD;
; 647  :                 break;

  0023d	e9 4d 13 00 00	 jmp	 $LN1111@inflate
$LN32@inflate:

; 670  : #ifdef GUNZIP
; 671  :         case FLAGS:
; 672  :             NEEDBITS(16);

  00242	83 fe 10	 cmp	 esi, 16			; 00000010H
  00245	73 2a		 jae	 SHORT $LN30@inflate
$LL33@inflate:
  00247	85 db		 test	 ebx, ebx
  00249	0f 84 8b 03 00
	00		 je	 $LN905@inflate
  0024f	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00252	8b ce		 mov	 ecx, esi
  00254	d3 e0		 shl	 eax, cl
  00256	83 c6 08	 add	 esi, 8
  00259	4b		 dec	 ebx
  0025a	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  0025d	03 d0		 add	 edx, eax
  0025f	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00262	47		 inc	 edi
  00263	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00266	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  00269	83 fe 10	 cmp	 esi, 16			; 00000010H
  0026c	72 d9		 jb	 SHORT $LL33@inflate
  0026e	8b 4d f0	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN30@inflate:

; 673  :             state->flags = (int)(hold);

  00271	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 674  :             if ((state->flags & 0xff) != Z_DEFLATED) {

  00274	80 fa 08	 cmp	 dl, 8
  00277	74 0f		 je	 SHORT $LN349@inflate

; 675  :                 strm->msg = (char *)"unknown compression method";

  00279	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0027c	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BL@IHKGDAEE@unknown?5compression?5method@

; 676  :                 state->mode = BAD;
; 677  :                 break;

  00283	e9 07 13 00 00	 jmp	 $LN1111@inflate
$LN349@inflate:

; 678  :             }
; 679  :             if (state->flags & 0xe000) {

  00288	f7 c2 00 e0 00
	00		 test	 edx, 57344		; 0000e000H
  0028e	74 0f		 je	 SHORT $LN350@inflate

; 680  :                 strm->msg = (char *)"unknown header flags set";

  00290	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00293	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@

; 681  :                 state->mode = BAD;
; 682  :                 break;

  0029a	e9 f0 12 00 00	 jmp	 $LN1111@inflate
$LN350@inflate:

; 683  :             }
; 684  :             if (state->head != Z_NULL)

  0029f	8b 71 24	 mov	 esi, DWORD PTR [ecx+36]
  002a2	85 f6		 test	 esi, esi
  002a4	74 0a		 je	 SHORT $LN722@inflate

; 685  :                 state->head->text = (int)((hold >> 8) & 1);

  002a6	8b c2		 mov	 eax, edx
  002a8	c1 e8 08	 shr	 eax, 8
  002ab	83 e0 01	 and	 eax, 1
  002ae	89 06		 mov	 DWORD PTR [esi], eax
$LN722@inflate:

; 686  :             if ((state->flags & 0x0200) && (state->wrap & 4))

  002b0	f7 41 14 00 02
	00 00		 test	 DWORD PTR [ecx+20], 512	; 00000200H
  002b7	74 23		 je	 SHORT $LN39@inflate
  002b9	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  002bd	74 1d		 je	 SHORT $LN39@inflate

; 687  :                 CRC2(state->check, hold);

  002bf	6a 02		 push	 2
  002c1	8d 45 e0	 lea	 eax, DWORD PTR _hbuf$[ebp]
  002c4	88 55 e0	 mov	 BYTE PTR _hbuf$[ebp], dl
  002c7	50		 push	 eax
  002c8	ff 71 1c	 push	 DWORD PTR [ecx+28]
  002cb	c1 ea 08	 shr	 edx, 8
  002ce	88 55 e1	 mov	 BYTE PTR _hbuf$[ebp+1], dl
  002d1	e8 00 00 00 00	 call	 _crc32@12
  002d6	8b 4d f0	 mov	 ecx, DWORD PTR _state$1$[ebp]
  002d9	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
$LN39@inflate:

; 688  :             INITBITS();

  002dc	33 d2		 xor	 edx, edx

; 689  :             state->mode = TIME;

  002de	c7 41 04 36 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16182 ; 00003f36H
  002e5	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  002e8	33 f6		 xor	 esi, esi

; 690  :                 /* fallthrough */
; 691  :         case TIME:
; 692  :             NEEDBITS(32);

  002ea	eb 05		 jmp	 SHORT $LL47@inflate
$LN46@inflate:
  002ec	83 fe 20	 cmp	 esi, 32			; 00000020H
  002ef	73 27		 jae	 SHORT $LN44@inflate
$LL47@inflate:
  002f1	85 db		 test	 ebx, ebx
  002f3	0f 84 e1 02 00
	00		 je	 $LN905@inflate
  002f9	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  002fc	8b ce		 mov	 ecx, esi
  002fe	d3 e0		 shl	 eax, cl
  00300	4b		 dec	 ebx
  00301	03 d0		 add	 edx, eax
  00303	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00306	47		 inc	 edi
  00307	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  0030a	83 c6 08	 add	 esi, 8
  0030d	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  00310	83 fe 20	 cmp	 esi, 32			; 00000020H
  00313	72 dc		 jb	 SHORT $LL47@inflate
  00315	8b 4d f0	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN44@inflate:

; 693  :             if (state->head != Z_NULL)

  00318	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  0031b	85 c0		 test	 eax, eax
  0031d	74 03		 je	 SHORT $LN355@inflate

; 694  :                 state->head->time = hold;

  0031f	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN355@inflate:

; 695  :             if ((state->flags & 0x0200) && (state->wrap & 4))

  00322	f7 41 14 00 02
	00 00		 test	 DWORD PTR [ecx+20], 512	; 00000200H
  00329	74 33		 je	 SHORT $LN53@inflate
  0032b	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  0032f	74 2d		 je	 SHORT $LN53@inflate

; 696  :                 CRC4(state->check, hold);

  00331	8b c2		 mov	 eax, edx
  00333	88 55 e0	 mov	 BYTE PTR _hbuf$[ebp], dl
  00336	c1 e8 08	 shr	 eax, 8
  00339	88 45 e1	 mov	 BYTE PTR _hbuf$[ebp+1], al
  0033c	8b c2		 mov	 eax, edx
  0033e	c1 e8 10	 shr	 eax, 16			; 00000010H
  00341	88 45 e2	 mov	 BYTE PTR _hbuf$[ebp+2], al
  00344	8d 45 e0	 lea	 eax, DWORD PTR _hbuf$[ebp]
  00347	6a 04		 push	 4
  00349	50		 push	 eax
  0034a	ff 71 1c	 push	 DWORD PTR [ecx+28]
  0034d	c1 ea 18	 shr	 edx, 24			; 00000018H
  00350	88 55 e3	 mov	 BYTE PTR _hbuf$[ebp+3], dl
  00353	e8 00 00 00 00	 call	 _crc32@12
  00358	8b 4d f0	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0035b	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
$LN53@inflate:

; 697  :             INITBITS();

  0035e	33 d2		 xor	 edx, edx

; 698  :             state->mode = OS;

  00360	c7 41 04 37 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16183 ; 00003f37H
  00367	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  0036a	33 f6		 xor	 esi, esi

; 699  :                 /* fallthrough */
; 700  :         case OS:
; 701  :             NEEDBITS(16);

  0036c	eb 05		 jmp	 SHORT $LL61@inflate
$LN60@inflate:
  0036e	83 fe 10	 cmp	 esi, 16			; 00000010H
  00371	73 27		 jae	 SHORT $LN58@inflate
$LL61@inflate:
  00373	85 db		 test	 ebx, ebx
  00375	0f 84 5f 02 00
	00		 je	 $LN905@inflate
  0037b	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0037e	8b ce		 mov	 ecx, esi
  00380	d3 e0		 shl	 eax, cl
  00382	4b		 dec	 ebx
  00383	03 d0		 add	 edx, eax
  00385	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00388	47		 inc	 edi
  00389	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  0038c	83 c6 08	 add	 esi, 8
  0038f	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  00392	83 fe 10	 cmp	 esi, 16			; 00000010H
  00395	72 dc		 jb	 SHORT $LL61@inflate
  00397	8b 4d f0	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN58@inflate:

; 702  :             if (state->head != Z_NULL) {

  0039a	8b 71 24	 mov	 esi, DWORD PTR [ecx+36]
  0039d	8b c2		 mov	 eax, edx
  0039f	c1 e8 08	 shr	 eax, 8
  003a2	89 45 c8	 mov	 DWORD PTR $T9[ebp], eax
  003a5	85 f6		 test	 esi, esi
  003a7	74 11		 je	 SHORT $LN723@inflate

; 703  :                 state->head->xflags = (int)(hold & 0xff);

  003a9	0f b6 c2	 movzx	 eax, dl
  003ac	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 704  :                 state->head->os = (int)(hold >> 8);

  003af	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  003b2	8b 75 c8	 mov	 esi, DWORD PTR $T9[ebp]
  003b5	89 70 0c	 mov	 DWORD PTR [eax+12], esi
  003b8	8b c6		 mov	 eax, esi
$LN723@inflate:

; 705  :             }
; 706  :             if ((state->flags & 0x0200) && (state->wrap & 4))

  003ba	f7 41 14 00 02
	00 00		 test	 DWORD PTR [ecx+20], 512	; 00000200H
  003c1	74 20		 je	 SHORT $LN67@inflate
  003c3	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  003c7	74 1a		 je	 SHORT $LN67@inflate

; 707  :                 CRC2(state->check, hold);

  003c9	88 45 e1	 mov	 BYTE PTR _hbuf$[ebp+1], al
  003cc	8d 45 e0	 lea	 eax, DWORD PTR _hbuf$[ebp]
  003cf	6a 02		 push	 2
  003d1	50		 push	 eax
  003d2	ff 71 1c	 push	 DWORD PTR [ecx+28]
  003d5	88 55 e0	 mov	 BYTE PTR _hbuf$[ebp], dl
  003d8	e8 00 00 00 00	 call	 _crc32@12
  003dd	8b 4d f0	 mov	 ecx, DWORD PTR _state$1$[ebp]
  003e0	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
$LN67@inflate:

; 708  :             INITBITS();

  003e3	33 d2		 xor	 edx, edx

; 709  :             state->mode = EXLEN;

  003e5	c7 41 04 38 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16184 ; 00003f38H
  003ec	33 f6		 xor	 esi, esi
  003ee	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  003f1	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
$LN361@inflate:

; 710  :                 /* fallthrough */
; 711  :         case EXLEN:
; 712  :             if (state->flags & 0x0400) {

  003f4	f7 41 14 00 04
	00 00		 test	 DWORD PTR [ecx+20], 1024 ; 00000400H
  003fb	74 73		 je	 SHORT $LN362@inflate

; 713  :                 NEEDBITS(16);

  003fd	83 fe 10	 cmp	 esi, 16			; 00000010H
  00400	73 27		 jae	 SHORT $LN72@inflate
$LL75@inflate:
  00402	85 db		 test	 ebx, ebx
  00404	0f 84 d0 01 00
	00		 je	 $LN905@inflate
  0040a	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0040d	8b ce		 mov	 ecx, esi
  0040f	d3 e0		 shl	 eax, cl
  00411	4b		 dec	 ebx
  00412	03 d0		 add	 edx, eax
  00414	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00417	47		 inc	 edi
  00418	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  0041b	83 c6 08	 add	 esi, 8
  0041e	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  00421	83 fe 10	 cmp	 esi, 16			; 00000010H
  00424	72 dc		 jb	 SHORT $LL75@inflate
  00426	8b 4d f0	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN72@inflate:

; 714  :                 state->length = (unsigned)(hold);
; 715  :                 if (state->head != Z_NULL)

  00429	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  0042c	89 51 44	 mov	 DWORD PTR [ecx+68], edx
  0042f	85 c0		 test	 eax, eax
  00431	74 03		 je	 SHORT $LN365@inflate

; 716  :                     state->head->extra_len = (unsigned)hold;

  00433	89 50 14	 mov	 DWORD PTR [eax+20], edx
$LN365@inflate:

; 717  :                 if ((state->flags & 0x0200) && (state->wrap & 4))

  00436	f7 41 14 00 02
	00 00		 test	 DWORD PTR [ecx+20], 512	; 00000200H
  0043d	74 23		 je	 SHORT $LN81@inflate
  0043f	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  00443	74 1d		 je	 SHORT $LN81@inflate

; 718  :                     CRC2(state->check, hold);

  00445	6a 02		 push	 2
  00447	8d 45 e0	 lea	 eax, DWORD PTR _hbuf$[ebp]
  0044a	88 55 e0	 mov	 BYTE PTR _hbuf$[ebp], dl
  0044d	50		 push	 eax
  0044e	ff 71 1c	 push	 DWORD PTR [ecx+28]
  00451	c1 ea 08	 shr	 edx, 8
  00454	88 55 e1	 mov	 BYTE PTR _hbuf$[ebp+1], dl
  00457	e8 00 00 00 00	 call	 _crc32@12
  0045c	8b 4d f0	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0045f	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
$LN81@inflate:

; 719  :                 INITBITS();

  00462	33 f6		 xor	 esi, esi
  00464	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hold$1$[ebp], 0
  0046b	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi

; 720  :             }

  0046e	eb 0e		 jmp	 SHORT $LN367@inflate
$LN362@inflate:

; 721  :             else if (state->head != Z_NULL)

  00470	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  00473	85 c0		 test	 eax, eax
  00475	74 07		 je	 SHORT $LN367@inflate

; 722  :                 state->head->extra = Z_NULL;

  00477	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
$LN367@inflate:

; 723  :             state->mode = EXTRA;

  0047e	c7 41 04 39 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16185 ; 00003f39H
$LN368@inflate:

; 724  :                 /* fallthrough */
; 725  :         case EXTRA:
; 726  :             if (state->flags & 0x0400) {

  00485	f7 41 14 00 04
	00 00		 test	 DWORD PTR [ecx+20], 1024 ; 00000400H
  0048c	0f 84 b0 00 00
	00		 je	 $LN374@inflate

; 727  :                 copy = state->length;

  00492	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]

; 728  :                 if (copy > have) copy = have;
; 729  :                 if (copy) {

  00495	8b d3		 mov	 edx, ebx
  00497	3b c3		 cmp	 eax, ebx
  00499	0f 46 d0	 cmovbe	 edx, eax
  0049c	89 55 cc	 mov	 DWORD PTR tv4686[ebp], edx
  0049f	85 d2		 test	 edx, edx
  004a1	0f 84 93 00 00
	00		 je	 $LN371@inflate

; 730  :                     if (state->head != Z_NULL &&
; 731  :                         state->head->extra != Z_NULL &&

  004a7	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  004ab	8b 7d ec	 mov	 edi, DWORD PTR _next$1$[ebp]
  004ae	74 56		 je	 SHORT $LN372@inflate
  004b0	8b 59 24	 mov	 ebx, DWORD PTR [ecx+36]
  004b3	8b 5b 10	 mov	 ebx, DWORD PTR [ebx+16]
  004b6	85 db		 test	 ebx, ebx
  004b8	89 5d bc	 mov	 DWORD PTR tv4969[ebp], ebx
  004bb	8b 5d f4	 mov	 ebx, DWORD PTR _have$1$[ebp]
  004be	74 46		 je	 SHORT $LN372@inflate
  004c0	8b 79 24	 mov	 edi, DWORD PTR [ecx+36]
  004c3	8b 7f 14	 mov	 edi, DWORD PTR [edi+20]
  004c6	2b f8		 sub	 edi, eax
  004c8	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  004cb	89 7d d4	 mov	 DWORD PTR _len$2$[ebp], edi
  004ce	8b 78 18	 mov	 edi, DWORD PTR [eax+24]
  004d1	8b 45 d4	 mov	 eax, DWORD PTR _len$2$[ebp]
  004d4	3b c7		 cmp	 eax, edi
  004d6	89 7d c8	 mov	 DWORD PTR tv4968[ebp], edi
  004d9	8b 7d ec	 mov	 edi, DWORD PTR _next$1$[ebp]
  004dc	73 28		 jae	 SHORT $LN372@inflate

; 732  :                         (len = state->head->extra_len - state->length) <
; 733  :                             state->head->extra_max) {
; 734  :                         zmemcpy(state->head->extra + len, next,

  004de	8d 0c 02	 lea	 ecx, DWORD PTR [edx+eax]
  004e1	8b 55 c8	 mov	 edx, DWORD PTR tv4968[ebp]
  004e4	2b d0		 sub	 edx, eax
  004e6	3b 4d c8	 cmp	 ecx, DWORD PTR tv4968[ebp]
  004e9	8b 45 cc	 mov	 eax, DWORD PTR tv4686[ebp]
  004ec	0f 47 c2	 cmova	 eax, edx
  004ef	50		 push	 eax
  004f0	8b 45 d4	 mov	 eax, DWORD PTR _len$2$[ebp]
  004f3	03 45 bc	 add	 eax, DWORD PTR tv4969[ebp]
  004f6	57		 push	 edi
  004f7	50		 push	 eax
  004f8	e8 00 00 00 00	 call	 _memcpy
  004fd	8b 4d f0	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00500	83 c4 0c	 add	 esp, 12			; 0000000cH
  00503	8b 55 cc	 mov	 edx, DWORD PTR tv4686[ebp]
$LN372@inflate:

; 735  :                                 len + copy > state->head->extra_max ?
; 736  :                                 state->head->extra_max - len : copy);
; 737  :                     }
; 738  :                     if ((state->flags & 0x0200) && (state->wrap & 4))

  00506	f7 41 14 00 02
	00 00		 test	 DWORD PTR [ecx+20], 512	; 00000200H
  0050d	74 16		 je	 SHORT $LN373@inflate
  0050f	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  00513	74 10		 je	 SHORT $LN373@inflate

; 739  :                         state->check = crc32(state->check, next, copy);

  00515	52		 push	 edx
  00516	57		 push	 edi
  00517	ff 71 1c	 push	 DWORD PTR [ecx+28]
  0051a	e8 00 00 00 00	 call	 _crc32@12
  0051f	8b 4d f0	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00522	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
$LN373@inflate:

; 740  :                     have -= copy;

  00525	8b 55 cc	 mov	 edx, DWORD PTR tv4686[ebp]
  00528	2b da		 sub	 ebx, edx

; 741  :                     next += copy;
; 742  :                     state->length -= copy;

  0052a	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]
  0052d	03 fa		 add	 edi, edx
  0052f	2b c2		 sub	 eax, edx
  00531	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00534	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  00537	89 41 44	 mov	 DWORD PTR [ecx+68], eax
$LN371@inflate:

; 743  :                 }
; 744  :                 if (state->length) goto inf_leave;

  0053a	85 c0		 test	 eax, eax
  0053c	0f 85 98 00 00
	00		 jne	 $LN905@inflate
$LN374@inflate:

; 745  :             }
; 746  :             state->length = 0;

  00542	c7 41 44 00 00
	00 00		 mov	 DWORD PTR [ecx+68], 0

; 747  :             state->mode = NAME;

  00549	c7 41 04 3a 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16186 ; 00003f3aH
$LN375@inflate:

; 748  :                 /* fallthrough */
; 749  :         case NAME:
; 750  :             if (state->flags & 0x0800) {

  00550	f7 41 14 00 08
	00 00		 test	 DWORD PTR [ecx+20], 2048 ; 00000800H
  00557	0f 84 06 01 00
	00		 je	 $LN376@inflate

; 751  :                 if (have == 0) goto inf_leave;

  0055d	85 db		 test	 ebx, ebx
  0055f	0f 84 75 00 00
	00		 je	 $LN905@inflate

; 752  :                 copy = 0;

  00565	33 d2		 xor	 edx, edx
$LL88@inflate:

; 753  :                 do {
; 754  :                     len = (unsigned)(next[copy++]);

  00567	8a 04 3a	 mov	 al, BYTE PTR [edx+edi]
  0056a	42		 inc	 edx
  0056b	88 45 ff	 mov	 BYTE PTR tv5104[ebp], al

; 755  :                     if (state->head != Z_NULL &&
; 756  :                             state->head->name != Z_NULL &&

  0056e	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  00571	85 c0		 test	 eax, eax
  00573	74 1d		 je	 SHORT $LN86@inflate
  00575	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00579	74 17		 je	 SHORT $LN86@inflate
  0057b	8b 71 44	 mov	 esi, DWORD PTR [ecx+68]
  0057e	3b 70 20	 cmp	 esi, DWORD PTR [eax+32]
  00581	73 0f		 jae	 SHORT $LN86@inflate

; 757  :                             state->length < state->head->name_max)
; 758  :                         state->head->name[state->length++] = (Bytef)len;

  00583	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  00586	8a 5d ff	 mov	 bl, BYTE PTR tv5104[ebp]
  00589	88 1c 30	 mov	 BYTE PTR [eax+esi], bl
  0058c	ff 41 44	 inc	 DWORD PTR [ecx+68]
  0058f	8b 5d f4	 mov	 ebx, DWORD PTR _have$1$[ebp]
$LN86@inflate:

; 759  :                 } while (len && copy < have);

  00592	8a 45 ff	 mov	 al, BYTE PTR tv5104[ebp]
  00595	84 c0		 test	 al, al
  00597	74 04		 je	 SHORT $LN380@inflate
  00599	3b d3		 cmp	 edx, ebx
  0059b	72 ca		 jb	 SHORT $LL88@inflate
$LN380@inflate:

; 760  :                 if ((state->flags & 0x0200) && (state->wrap & 4))

  0059d	f7 41 14 00 02
	00 00		 test	 DWORD PTR [ecx+20], 512	; 00000200H
  005a4	8b 75 e8	 mov	 esi, DWORD PTR _bits$1$[ebp]
  005a7	89 55 bc	 mov	 DWORD PTR _copy$1$[ebp], edx
  005aa	74 1c		 je	 SHORT $LN381@inflate
  005ac	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  005b0	74 16		 je	 SHORT $LN381@inflate

; 761  :                     state->check = crc32(state->check, next, copy);

  005b2	52		 push	 edx
  005b3	57		 push	 edi
  005b4	ff 71 1c	 push	 DWORD PTR [ecx+28]
  005b7	e8 00 00 00 00	 call	 _crc32@12
  005bc	8b 4d f0	 mov	 ecx, DWORD PTR _state$1$[ebp]
  005bf	8b 55 bc	 mov	 edx, DWORD PTR _copy$1$[ebp]
  005c2	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  005c5	8a 45 ff	 mov	 al, BYTE PTR tv5104[ebp]
$LN381@inflate:

; 762  :                 have -= copy;

  005c8	2b da		 sub	 ebx, edx

; 763  :                 next += copy;

  005ca	03 fa		 add	 edi, edx
  005cc	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  005cf	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi

; 764  :                 if (len) goto inf_leave;

  005d2	84 c0		 test	 al, al
  005d4	0f 84 97 00 00
	00		 je	 $LN383@inflate
$LN905@inflate:

; 1227 :             goto inf_leave;
; 1228 :         case MEM:
; 1229 :             return Z_MEM_ERROR;
; 1230 :         case SYNC:
; 1231 :                 /* fallthrough */
; 1232 :         default:
; 1233 :             return Z_STREAM_ERROR;
; 1234 :         }
; 1235 : 
; 1236 :     /*
; 1237 :        Return from inflate(), updating the total counts and the check value.
; 1238 :        If there was no progress during the inflate() call, return a buffer
; 1239 :        error.  Call updatewindow() to create and/or update the window state.
; 1240 :        Note: a memory error from inflate() is non-recoverable.
; 1241 :      */
; 1242 :   inf_leave:
; 1243 :     RESTORE();

  005da	8b 45 f4	 mov	 eax, DWORD PTR _have$1$[ebp]
$LN915@inflate:
  005dd	8b 55 0c	 mov	 edx, DWORD PTR _flush$[ebp]
$inf_leave$1117:
  005e0	8b 7d 08	 mov	 edi, DWORD PTR _strm$[ebp]
  005e3	8b 4d dc	 mov	 ecx, DWORD PTR _put$1$[ebp]
  005e6	8b 5d f0	 mov	 ebx, DWORD PTR _state$1$[ebp]
  005e9	89 4f 0c	 mov	 DWORD PTR [edi+12], ecx
  005ec	8b 4d e4	 mov	 ecx, DWORD PTR _left$1$[ebp]
  005ef	89 4f 10	 mov	 DWORD PTR [edi+16], ecx
  005f2	8b 4d ec	 mov	 ecx, DWORD PTR _next$1$[ebp]
  005f5	89 47 04	 mov	 DWORD PTR [edi+4], eax
  005f8	8b 45 f8	 mov	 eax, DWORD PTR _hold$1$[ebp]
  005fb	89 0f		 mov	 DWORD PTR [edi], ecx

; 1244 :     if (state->wsize || (out != strm->avail_out && state->mode < BAD &&

  005fd	83 7b 2c 00	 cmp	 DWORD PTR [ebx+44], 0
  00601	89 73 40	 mov	 DWORD PTR [ebx+64], esi
  00604	8b 75 d8	 mov	 esi, DWORD PTR _out$1$[ebp]
  00607	89 43 3c	 mov	 DWORD PTR [ebx+60], eax
  0060a	75 27		 jne	 SHORT $LN503@inflate
  0060c	3b 77 10	 cmp	 esi, DWORD PTR [edi+16]
  0060f	0f 84 f8 0f 00
	00		 je	 $LN504@inflate
  00615	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00618	3d 51 3f 00 00	 cmp	 eax, 16209		; 00003f51H
  0061d	0f 8d ea 0f 00
	00		 jge	 $LN504@inflate
  00623	3d 4e 3f 00 00	 cmp	 eax, 16206		; 00003f4eH
  00628	7c 09		 jl	 SHORT $LN503@inflate
  0062a	83 fa 04	 cmp	 edx, 4
  0062d	0f 84 da 0f 00
	00		 je	 $LN504@inflate
$LN503@inflate:

; 1245 :             (state->mode < CHECK || flush != Z_FINISH)))
; 1246 :         if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {

  00633	8b 57 0c	 mov	 edx, DWORD PTR [edi+12]
  00636	8b c6		 mov	 eax, esi
  00638	2b 47 10	 sub	 eax, DWORD PTR [edi+16]
  0063b	8b cf		 mov	 ecx, edi
  0063d	50		 push	 eax
  0063e	e8 00 00 00 00	 call	 _updatewindow
  00643	83 c4 04	 add	 esp, 4
  00646	85 c0		 test	 eax, eax
  00648	0f 84 bf 0f 00
	00		 je	 $LN504@inflate

; 1247 :             state->mode = MEM;

  0064e	c7 43 04 52 3f
	00 00		 mov	 DWORD PTR [ebx+4], 16210 ; 00003f52H
$LN498@inflate:
  00655	5f		 pop	 edi

; 1262 :         ret = Z_BUF_ERROR;
; 1263 :     return ret;
; 1264 : }

  00656	5e		 pop	 esi
  00657	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  0065c	5b		 pop	 ebx
  0065d	8b e5		 mov	 esp, ebp
  0065f	5d		 pop	 ebp
  00660	c2 08 00	 ret	 8
$LN376@inflate:

; 765  :             }
; 766  :             else if (state->head != Z_NULL)

  00663	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  00666	85 c0		 test	 eax, eax
  00668	74 07		 je	 SHORT $LN383@inflate

; 767  :                 state->head->name = Z_NULL;

  0066a	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0
$LN383@inflate:

; 768  :             state->length = 0;

  00671	c7 41 44 00 00
	00 00		 mov	 DWORD PTR [ecx+68], 0

; 769  :             state->mode = COMMENT;

  00678	c7 41 04 3b 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16187 ; 00003f3bH
$LN384@inflate:

; 770  :                 /* fallthrough */
; 771  :         case COMMENT:
; 772  :             if (state->flags & 0x1000) {

  0067f	f7 41 14 00 10
	00 00		 test	 DWORD PTR [ecx+20], 4096 ; 00001000H
  00686	0f 84 7f 00 00
	00		 je	 $LN385@inflate

; 773  :                 if (have == 0) goto inf_leave;

  0068c	85 db		 test	 ebx, ebx
  0068e	0f 84 46 ff ff
	ff		 je	 $LN905@inflate

; 774  :                 copy = 0;

  00694	33 d2		 xor	 edx, edx
$LL91@inflate:

; 775  :                 do {
; 776  :                     len = (unsigned)(next[copy++]);

  00696	8a 04 3a	 mov	 al, BYTE PTR [edx+edi]
  00699	42		 inc	 edx
  0069a	88 45 ff	 mov	 BYTE PTR tv5103[ebp], al

; 777  :                     if (state->head != Z_NULL &&
; 778  :                             state->head->comment != Z_NULL &&

  0069d	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  006a0	85 c0		 test	 eax, eax
  006a2	74 1d		 je	 SHORT $LN89@inflate
  006a4	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  006a8	74 17		 je	 SHORT $LN89@inflate
  006aa	8b 71 44	 mov	 esi, DWORD PTR [ecx+68]
  006ad	3b 70 28	 cmp	 esi, DWORD PTR [eax+40]
  006b0	73 0f		 jae	 SHORT $LN89@inflate

; 779  :                             state->length < state->head->comm_max)
; 780  :                         state->head->comment[state->length++] = (Bytef)len;

  006b2	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  006b5	8a 5d ff	 mov	 bl, BYTE PTR tv5103[ebp]
  006b8	88 1c 30	 mov	 BYTE PTR [eax+esi], bl
  006bb	ff 41 44	 inc	 DWORD PTR [ecx+68]
  006be	8b 5d f4	 mov	 ebx, DWORD PTR _have$1$[ebp]
$LN89@inflate:

; 781  :                 } while (len && copy < have);

  006c1	8a 45 ff	 mov	 al, BYTE PTR tv5103[ebp]
  006c4	84 c0		 test	 al, al
  006c6	74 04		 je	 SHORT $LN389@inflate
  006c8	3b d3		 cmp	 edx, ebx
  006ca	72 ca		 jb	 SHORT $LL91@inflate
$LN389@inflate:

; 782  :                 if ((state->flags & 0x0200) && (state->wrap & 4))

  006cc	f7 41 14 00 02
	00 00		 test	 DWORD PTR [ecx+20], 512	; 00000200H
  006d3	8b 75 e8	 mov	 esi, DWORD PTR _bits$1$[ebp]
  006d6	89 55 bc	 mov	 DWORD PTR _copy$2$[ebp], edx
  006d9	74 1c		 je	 SHORT $LN390@inflate
  006db	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  006df	74 16		 je	 SHORT $LN390@inflate

; 783  :                     state->check = crc32(state->check, next, copy);

  006e1	52		 push	 edx
  006e2	57		 push	 edi
  006e3	ff 71 1c	 push	 DWORD PTR [ecx+28]
  006e6	e8 00 00 00 00	 call	 _crc32@12
  006eb	8b 4d f0	 mov	 ecx, DWORD PTR _state$1$[ebp]
  006ee	8b 55 bc	 mov	 edx, DWORD PTR _copy$2$[ebp]
  006f1	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  006f4	8a 45 ff	 mov	 al, BYTE PTR tv5103[ebp]
$LN390@inflate:

; 784  :                 have -= copy;

  006f7	2b da		 sub	 ebx, edx

; 785  :                 next += copy;

  006f9	03 fa		 add	 edi, edx
  006fb	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  006fe	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi

; 786  :                 if (len) goto inf_leave;

  00701	84 c0		 test	 al, al
  00703	0f 85 d1 fe ff
	ff		 jne	 $LN905@inflate

; 787  :             }

  00709	eb 0e		 jmp	 SHORT $LN392@inflate
$LN385@inflate:

; 788  :             else if (state->head != Z_NULL)

  0070b	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  0070e	85 c0		 test	 eax, eax
  00710	74 07		 je	 SHORT $LN392@inflate

; 789  :                 state->head->comment = Z_NULL;

  00712	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], 0
$LN392@inflate:
  00719	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]

; 790  :             state->mode = HCRC;

  0071c	c7 41 04 3c 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16188 ; 00003f3cH
$LN393@inflate:

; 791  :                 /* fallthrough */
; 792  :         case HCRC:
; 793  :             if (state->flags & 0x0200) {

  00723	f7 41 14 00 02
	00 00		 test	 DWORD PTR [ecx+20], 512	; 00000200H
  0072a	74 58		 je	 SHORT $LN101@inflate

; 794  :                 NEEDBITS(16);

  0072c	83 fe 10	 cmp	 esi, 16			; 00000010H
  0072f	73 2a		 jae	 SHORT $LN92@inflate
$LL95@inflate:
  00731	85 db		 test	 ebx, ebx
  00733	0f 84 a1 fe ff
	ff		 je	 $LN905@inflate
  00739	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0073c	8b ce		 mov	 ecx, esi
  0073e	d3 e0		 shl	 eax, cl
  00740	83 c6 08	 add	 esi, 8
  00743	4b		 dec	 ebx
  00744	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  00747	03 d0		 add	 edx, eax
  00749	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  0074c	47		 inc	 edi
  0074d	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00750	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  00753	83 fe 10	 cmp	 esi, 16			; 00000010H
  00756	72 d9		 jb	 SHORT $LL95@inflate
  00758	8b 4d f0	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN92@inflate:

; 795  :                 if ((state->wrap & 4) && hold != (state->check & 0xffff)) {

  0075b	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  0075f	74 17		 je	 SHORT $LN102@inflate
  00761	0f b7 41 1c	 movzx	 eax, WORD PTR [ecx+28]
  00765	3b d0		 cmp	 edx, eax
  00767	74 0f		 je	 SHORT $LN102@inflate

; 796  :                     strm->msg = (char *)"header crc mismatch";

  00769	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0076c	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BE@GONKLEPM@header?5crc?5mismatch@

; 797  :                     state->mode = BAD;
; 798  :                     break;

  00773	e9 17 0e 00 00	 jmp	 $LN1111@inflate
$LN102@inflate:

; 799  :                 }
; 800  :                 INITBITS();

  00778	33 f6		 xor	 esi, esi
  0077a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hold$1$[ebp], 0
  00781	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
$LN101@inflate:

; 801  :             }
; 802  :             if (state->head != Z_NULL) {

  00784	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00787	85 d2		 test	 edx, edx
  00789	74 16		 je	 SHORT $LN397@inflate

; 803  :                 state->head->hcrc = (int)((state->flags >> 9) & 1);

  0078b	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  0078e	c1 f8 09	 sar	 eax, 9
  00791	83 e0 01	 and	 eax, 1
  00794	89 42 2c	 mov	 DWORD PTR [edx+44], eax

; 804  :                 state->head->done = 1;

  00797	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  0079a	c7 40 30 01 00
	00 00		 mov	 DWORD PTR [eax+48], 1
$LN397@inflate:

; 805  :             }
; 806  :             strm->adler = state->check = crc32(0L, Z_NULL, 0);

  007a1	6a 00		 push	 0
  007a3	6a 00		 push	 0
  007a5	6a 00		 push	 0
  007a7	e8 00 00 00 00	 call	 _crc32@12
  007ac	8b 4d f0	 mov	 ecx, DWORD PTR _state$1$[ebp]
  007af	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  007b2	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  007b5	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 807  :             state->mode = TYPE;
; 808  :             break;

  007b8	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  007bb	c7 41 04 3f 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16191 ; 00003f3fH
  007c2	e9 cf 0d 00 00	 jmp	 $LN8@inflate
$LN105@inflate:

; 809  : #endif
; 810  :         case DICTID:
; 811  :             NEEDBITS(32);

  007c7	83 fe 20	 cmp	 esi, 32			; 00000020H
  007ca	73 2b		 jae	 SHORT $LN103@inflate
  007cc	0f 1f 40 00	 npad	 4
$LL106@inflate:
  007d0	85 db		 test	 ebx, ebx
  007d2	0f 84 02 fe ff
	ff		 je	 $LN905@inflate
  007d8	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  007db	8b ce		 mov	 ecx, esi
  007dd	d3 e0		 shl	 eax, cl
  007df	4b		 dec	 ebx
  007e0	03 d0		 add	 edx, eax
  007e2	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  007e5	47		 inc	 edi
  007e6	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  007e9	83 c6 08	 add	 esi, 8
  007ec	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  007ef	83 fe 20	 cmp	 esi, 32			; 00000020H
  007f2	72 dc		 jb	 SHORT $LL106@inflate
  007f4	8b 4d f0	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN103@inflate:

; 812  :             strm->adler = state->check = ZSWAP32(hold);

  007f7	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  007fa	0f ca		 bswap	 edx
  007fc	89 51 1c	 mov	 DWORD PTR [ecx+28], edx
  007ff	89 50 30	 mov	 DWORD PTR [eax+48], edx

; 813  :             INITBITS();

  00802	33 d2		 xor	 edx, edx
  00804	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00807	33 f6		 xor	 esi, esi

; 814  :             state->mode = DICT;

  00809	c7 41 04 3e 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16190 ; 00003f3eH
  00810	eb 03		 jmp	 SHORT $LN400@inflate
$LN911@inflate:

; 620  :     for (;;)
; 621  :         switch (state->mode) {

  00812	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
$LN400@inflate:

; 815  :                 /* fallthrough */
; 816  :         case DICT:
; 817  :             if (state->havedict == 0) {

  00815	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  00819	0f 84 96 0d 00
	00		 je	 $LN587@inflate

; 820  :             }
; 821  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  0081f	6a 00		 push	 0
  00821	6a 00		 push	 0
  00823	6a 00		 push	 0
  00825	e8 00 00 00 00	 call	 _adler32@12
  0082a	8b 4d f0	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0082d	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00830	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  00833	89 42 30	 mov	 DWORD PTR [edx+48], eax
  00836	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]

; 822  :             state->mode = TYPE;

  00839	c7 41 04 3f 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16191 ; 00003f3fH
$LN402@inflate:

; 823  :                 /* fallthrough */
; 824  :         case TYPE:
; 825  :             if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;

  00840	8b 45 0c	 mov	 eax, DWORD PTR _flush$[ebp]
  00843	83 f8 05	 cmp	 eax, 5
  00846	0f 84 8e fd ff
	ff		 je	 $LN905@inflate
  0084c	83 f8 06	 cmp	 eax, 6
  0084f	0f 84 85 fd ff
	ff		 je	 $LN905@inflate
$LN403@inflate:

; 826  :                 /* fallthrough */
; 827  :         case TYPEDO:
; 828  :             if (state->last) {

  00855	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  00859	74 1e		 je	 SHORT $LN122@inflate

; 829  :                 BYTEBITS();

  0085b	8b ce		 mov	 ecx, esi
  0085d	83 e1 07	 and	 ecx, 7
  00860	d3 ea		 shr	 edx, cl
  00862	2b f1		 sub	 esi, ecx

; 830  :                 state->mode = CHECK;

  00864	8b 4d f0	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00867	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  0086a	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  0086d	c7 41 04 4e 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16206 ; 00003f4eH

; 831  :                 break;

  00874	e9 1d 0d 00 00	 jmp	 $LN8@inflate
$LN122@inflate:

; 832  :             }
; 833  :             NEEDBITS(3);

  00879	83 fe 03	 cmp	 esi, 3
  0087c	73 29		 jae	 SHORT $LN120@inflate
  0087e	66 90		 npad	 2
$LL123@inflate:
  00880	85 db		 test	 ebx, ebx
  00882	0f 84 52 fd ff
	ff		 je	 $LN905@inflate
  00888	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0088b	8b ce		 mov	 ecx, esi
  0088d	d3 e0		 shl	 eax, cl
  0088f	4b		 dec	 ebx
  00890	03 d0		 add	 edx, eax
  00892	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00895	47		 inc	 edi
  00896	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00899	83 c6 08	 add	 esi, 8
  0089c	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  0089f	83 fe 03	 cmp	 esi, 3
  008a2	72 dc		 jb	 SHORT $LL123@inflate
  008a4	8b 4d f0	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN120@inflate:

; 834  :             state->last = BITS(1);

  008a7	8b c2		 mov	 eax, edx

; 835  :             DROPBITS(1);

  008a9	d1 ea		 shr	 edx, 1
  008ab	83 e0 01	 and	 eax, 1
  008ae	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 836  :             switch (BITS(2)) {

  008b1	8b c2		 mov	 eax, edx
  008b3	83 e0 03	 and	 eax, 3
  008b6	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN788@inflate[eax*4]
$LN408@inflate:

; 860  :             }
; 861  :             DROPBITS(2);

  008bd	c1 ea 02	 shr	 edx, 2
  008c0	83 ee 03	 sub	 esi, 3
  008c3	c7 41 04 41 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16193 ; 00003f41H
  008ca	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  008cd	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi

; 862  :             break;

  008d0	e9 c1 0c 00 00	 jmp	 $LN8@inflate
$LN409@inflate:

; 837  :             case 0:                             /* stored block */
; 838  :                 Tracev((stderr, "inflate:     stored block%s\n",
; 839  :                         state->last ? " (last)" : ""));
; 840  :                 state->mode = STORED;
; 841  :                 break;
; 842  :             case 1:                             /* fixed block */
; 843  :                 fixedtables(state);

  008d5	e8 00 00 00 00	 call	 _fixedtables

; 844  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 845  :                         state->last ? " (last)" : ""));
; 846  :                 state->mode = LEN_;             /* decode codes */
; 847  :                 if (flush == Z_TREES) {

  008da	83 7d 0c 06	 cmp	 DWORD PTR _flush$[ebp], 6
  008de	c7 41 04 47 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16199 ; 00003f47H
  008e5	75 37		 jne	 SHORT $LN138@inflate

; 848  :                     DROPBITS(2);

  008e7	c1 ea 02	 shr	 edx, 2
  008ea	83 ee 03	 sub	 esi, 3
  008ed	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx

; 1227 :             goto inf_leave;
; 1228 :         case MEM:
; 1229 :             return Z_MEM_ERROR;
; 1230 :         case SYNC:
; 1231 :                 /* fallthrough */
; 1232 :         default:
; 1233 :             return Z_STREAM_ERROR;
; 1234 :         }
; 1235 : 
; 1236 :     /*
; 1237 :        Return from inflate(), updating the total counts and the check value.
; 1238 :        If there was no progress during the inflate() call, return a buffer
; 1239 :        error.  Call updatewindow() to create and/or update the window state.
; 1240 :        Note: a memory error from inflate() is non-recoverable.
; 1241 :      */
; 1242 :   inf_leave:
; 1243 :     RESTORE();

  008f0	e9 e5 fc ff ff	 jmp	 $LN905@inflate
$LN411@inflate:

; 860  :             }
; 861  :             DROPBITS(2);

  008f5	c1 ea 02	 shr	 edx, 2
  008f8	83 ee 03	 sub	 esi, 3
  008fb	c7 41 04 44 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16196 ; 00003f44H
  00902	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00905	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi

; 862  :             break;

  00908	e9 89 0c 00 00	 jmp	 $LN8@inflate
$LN412@inflate:

; 849  :                     goto inf_leave;
; 850  :                 }
; 851  :                 break;
; 852  :             case 2:                             /* dynamic block */
; 853  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 854  :                         state->last ? " (last)" : ""));
; 855  :                 state->mode = TABLE;
; 856  :                 break;
; 857  :             case 3:
; 858  :                 strm->msg = (char *)"invalid block type";

  0090d	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00910	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BD@PJCBIDD@invalid?5block?5type@

; 859  :                 state->mode = BAD;

  00917	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
$LN138@inflate:

; 860  :             }
; 861  :             DROPBITS(2);

  0091e	c1 ea 02	 shr	 edx, 2
  00921	83 ee 03	 sub	 esi, 3
  00924	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00927	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi

; 862  :             break;

  0092a	e9 67 0c 00 00	 jmp	 $LN8@inflate
$LN141@inflate:

; 863  :         case STORED:
; 864  :             BYTEBITS();                         /* go to byte boundary */

  0092f	8b ce		 mov	 ecx, esi
  00931	83 e1 07	 and	 ecx, 7
  00934	2b f1		 sub	 esi, ecx
  00936	d3 ea		 shr	 edx, cl
  00938	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  0093b	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi

; 865  :             NEEDBITS(32);

  0093e	83 fe 20	 cmp	 esi, 32			; 00000020H
  00941	73 27		 jae	 SHORT $LN142@inflate
$LL145@inflate:
  00943	85 db		 test	 ebx, ebx
  00945	0f 84 8f fc ff
	ff		 je	 $LN905@inflate
  0094b	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0094e	8b ce		 mov	 ecx, esi
  00950	d3 e0		 shl	 eax, cl
  00952	83 c6 08	 add	 esi, 8
  00955	4b		 dec	 ebx
  00956	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  00959	03 d0		 add	 edx, eax
  0095b	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  0095e	47		 inc	 edi
  0095f	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00962	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  00965	83 fe 20	 cmp	 esi, 32			; 00000020H
  00968	72 d9		 jb	 SHORT $LL145@inflate
$LN142@inflate:

; 866  :             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {

  0096a	8b c2		 mov	 eax, edx
  0096c	0f b7 ca	 movzx	 ecx, dx
  0096f	f7 d0		 not	 eax
  00971	89 4d bc	 mov	 DWORD PTR tv4963[ebp], ecx
  00974	c1 e8 10	 shr	 eax, 16			; 00000010H
  00977	3b c8		 cmp	 ecx, eax
  00979	8b 4d f0	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0097c	74 0f		 je	 SHORT $LN415@inflate

; 867  :                 strm->msg = (char *)"invalid stored block lengths";

  0097e	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00981	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths@

; 868  :                 state->mode = BAD;
; 869  :                 break;

  00988	e9 02 0c 00 00	 jmp	 $LN1111@inflate
$LN415@inflate:

; 870  :             }
; 871  :             state->length = (unsigned)hold & 0xffff;

  0098d	8b 45 bc	 mov	 eax, DWORD PTR tv4963[ebp]

; 872  :             Tracev((stderr, "inflate:       stored length %u\n",
; 873  :                     state->length));
; 874  :             INITBITS();

  00990	33 d2		 xor	 edx, edx
  00992	33 f6		 xor	 esi, esi
  00994	89 41 44	 mov	 DWORD PTR [ecx+68], eax

; 875  :             state->mode = COPY_;
; 876  :             if (flush == Z_TREES) goto inf_leave;

  00997	83 7d 0c 06	 cmp	 DWORD PTR _flush$[ebp], 6
  0099b	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  0099e	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  009a1	c7 41 04 42 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16194 ; 00003f42H
  009a8	0f 84 2c fc ff
	ff		 je	 $LN905@inflate
$LN416@inflate:

; 877  :                 /* fallthrough */
; 878  :         case COPY_:
; 879  :             state->mode = COPY;

  009ae	c7 41 04 43 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16195 ; 00003f43H
$LN418@inflate:

; 880  :                 /* fallthrough */
; 881  :         case COPY:
; 882  :             copy = state->length;

  009b5	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]
  009b8	89 45 bc	 mov	 DWORD PTR _copy$3$[ebp], eax

; 883  :             if (copy) {

  009bb	85 c0		 test	 eax, eax
  009bd	0f 84 49 07 00
	00		 je	 $LN419@inflate

; 884  :                 if (copy > have) copy = have;
; 885  :                 if (copy > left) copy = left;

  009c3	39 5d bc	 cmp	 DWORD PTR _copy$3$[ebp], ebx
  009c6	8b c3		 mov	 eax, ebx
  009c8	0f 46 45 bc	 cmovbe	 eax, DWORD PTR _copy$3$[ebp]
  009cc	3b 45 e4	 cmp	 eax, DWORD PTR _left$1$[ebp]
  009cf	0f 47 45 e4	 cmova	 eax, DWORD PTR _left$1$[ebp]
  009d3	89 45 bc	 mov	 DWORD PTR _copy$5$[ebp], eax

; 886  :                 if (copy == 0) goto inf_leave;

  009d6	85 c0		 test	 eax, eax
  009d8	0f 84 fc fb ff
	ff		 je	 $LN905@inflate

; 887  :                 zmemcpy(put, next, copy);

  009de	50		 push	 eax
  009df	57		 push	 edi
  009e0	ff 75 dc	 push	 DWORD PTR _put$1$[ebp]
  009e3	e8 00 00 00 00	 call	 _memcpy

; 888  :                 have -= copy;

  009e8	8b 45 bc	 mov	 eax, DWORD PTR _copy$5$[ebp]
  009eb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 889  :                 next += copy;
; 890  :                 left -= copy;
; 891  :                 put += copy;
; 892  :                 state->length -= copy;

  009ee	8b 4d f0	 mov	 ecx, DWORD PTR _state$1$[ebp]
  009f1	2b d8		 sub	 ebx, eax
  009f3	29 45 e4	 sub	 DWORD PTR _left$1$[ebp], eax
  009f6	03 f8		 add	 edi, eax
  009f8	01 45 dc	 add	 DWORD PTR _put$1$[ebp], eax

; 893  :                 break;

  009fb	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  009fe	29 41 44	 sub	 DWORD PTR [ecx+68], eax
  00a01	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00a04	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  00a07	e9 8a 0b 00 00	 jmp	 $LN8@inflate
$LN155@inflate:

; 894  :             }
; 895  :             Tracev((stderr, "inflate:       stored end\n"));
; 896  :             state->mode = TYPE;
; 897  :             break;
; 898  :         case TABLE:
; 899  :             NEEDBITS(14);

  00a0c	83 fe 0e	 cmp	 esi, 14			; 0000000eH
  00a0f	73 24		 jae	 SHORT $LN153@inflate
$LL156@inflate:
  00a11	85 db		 test	 ebx, ebx
  00a13	0f 84 c1 fb ff
	ff		 je	 $LN905@inflate
  00a19	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00a1c	8b ce		 mov	 ecx, esi
  00a1e	d3 e0		 shl	 eax, cl
  00a20	4b		 dec	 ebx
  00a21	03 d0		 add	 edx, eax
  00a23	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00a26	47		 inc	 edi
  00a27	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00a2a	83 c6 08	 add	 esi, 8
  00a2d	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  00a30	83 fe 0e	 cmp	 esi, 14			; 0000000eH
  00a33	72 dc		 jb	 SHORT $LL156@inflate
$LN153@inflate:

; 900  :             state->nlen = BITS(5) + 257;

  00a35	8b 45 f0	 mov	 eax, DWORD PTR _state$1$[ebp]
  00a38	8b ca		 mov	 ecx, edx

; 901  :             DROPBITS(5);

  00a3a	c1 ea 05	 shr	 edx, 5
  00a3d	83 e1 1f	 and	 ecx, 31			; 0000001fH

; 902  :             state->ndist = BITS(5) + 1;

  00a40	8b fa		 mov	 edi, edx
  00a42	81 c1 01 01 00
	00		 add	 ecx, 257		; 00000101H
  00a48	83 e7 1f	 and	 edi, 31			; 0000001fH

; 903  :             DROPBITS(5);

  00a4b	c1 ea 05	 shr	 edx, 5
  00a4e	47		 inc	 edi
  00a4f	89 48 64	 mov	 DWORD PTR [eax+100], ecx
  00a52	89 78 68	 mov	 DWORD PTR [eax+104], edi

; 904  :             state->ncode = BITS(4) + 4;
; 905  :             DROPBITS(4);

  00a55	83 ee 0e	 sub	 esi, 14			; 0000000eH
  00a58	89 7d bc	 mov	 DWORD PTR tv5163[ebp], edi
  00a5b	8b c2		 mov	 eax, edx
  00a5d	8b 7d f0	 mov	 edi, DWORD PTR _state$1$[ebp]
  00a60	83 e0 0f	 and	 eax, 15			; 0000000fH
  00a63	83 c0 04	 add	 eax, 4
  00a66	c1 ea 04	 shr	 edx, 4
  00a69	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00a6c	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  00a6f	89 47 60	 mov	 DWORD PTR [edi+96], eax

; 906  : #ifndef PKZIP_BUG_WORKAROUND
; 907  :             if (state->nlen > 286 || state->ndist > 30) {

  00a72	8b 7d ec	 mov	 edi, DWORD PTR _next$1$[ebp]
  00a75	81 f9 1e 01 00
	00		 cmp	 ecx, 286		; 0000011eH
  00a7b	0f 87 fc 00 00
	00		 ja	 $LN426@inflate
  00a81	83 7d bc 1e	 cmp	 DWORD PTR tv5163[ebp], 30 ; 0000001eH
  00a85	0f 87 f2 00 00
	00		 ja	 $LN426@inflate

; 911  :             }
; 912  : #endif
; 913  :             Tracev((stderr, "inflate:       table sizes ok\n"));
; 914  :             state->have = 0;

  00a8b	8b 4d f0	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00a8e	c7 41 6c 00 00
	00 00		 mov	 DWORD PTR [ecx+108], 0

; 915  :             state->mode = LENLENS;

  00a95	c7 41 04 45 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16197 ; 00003f45H
$LN533@inflate:

; 916  :                 /* fallthrough */
; 917  :         case LENLENS:
; 918  :             while (state->have < state->ncode) {

  00a9c	8b 41 6c	 mov	 eax, DWORD PTR [ecx+108]
  00a9f	3b 41 60	 cmp	 eax, DWORD PTR [ecx+96]
  00aa2	73 68		 jae	 SHORT $LN535@inflate
$LL170@inflate:

; 919  :                 NEEDBITS(3);

  00aa4	83 fe 03	 cmp	 esi, 3
  00aa7	73 2b		 jae	 SHORT $LN172@inflate
  00aa9	0f 1f 80 00 00
	00 00		 npad	 7
$LL175@inflate:
  00ab0	85 db		 test	 ebx, ebx
  00ab2	0f 84 22 fb ff
	ff		 je	 $LN905@inflate
  00ab8	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00abb	8b ce		 mov	 ecx, esi
  00abd	d3 e0		 shl	 eax, cl
  00abf	4b		 dec	 ebx
  00ac0	03 d0		 add	 edx, eax
  00ac2	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00ac5	47		 inc	 edi
  00ac6	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00ac9	83 c6 08	 add	 esi, 8
  00acc	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  00acf	83 fe 03	 cmp	 esi, 3
  00ad2	72 dc		 jb	 SHORT $LL175@inflate
$LN172@inflate:

; 920  :                 state->lens[order[state->have++]] = (unsigned short)BITS(3);

  00ad4	8b 45 f0	 mov	 eax, DWORD PTR _state$1$[ebp]
  00ad7	8b ca		 mov	 ecx, edx
  00ad9	8b 7d f0	 mov	 edi, DWORD PTR _state$1$[ebp]
  00adc	83 e1 07	 and	 ecx, 7

; 921  :                 DROPBITS(3);

  00adf	c1 ea 03	 shr	 edx, 3
  00ae2	83 ee 03	 sub	 esi, 3
  00ae5	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00ae8	8b 40 6c	 mov	 eax, DWORD PTR [eax+108]
  00aeb	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  00aee	0f b7 04 45 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflate@@9@9[eax*2]
  00af6	66 89 4c 47 74	 mov	 WORD PTR [edi+eax*2+116], cx
  00afb	8b cf		 mov	 ecx, edi
  00afd	8b 7d ec	 mov	 edi, DWORD PTR _next$1$[ebp]
  00b00	8b 41 6c	 mov	 eax, DWORD PTR [ecx+108]
  00b03	40		 inc	 eax
  00b04	89 41 6c	 mov	 DWORD PTR [ecx+108], eax
  00b07	3b 41 60	 cmp	 eax, DWORD PTR [ecx+96]
  00b0a	72 98		 jb	 SHORT $LL170@inflate
$LN535@inflate:

; 922  :             }
; 923  :             while (state->have < 19)

  00b0c	83 f8 13	 cmp	 eax, 19			; 00000013H
  00b0f	73 1b		 jae	 SHORT $LN184@inflate
$LL183@inflate:

; 924  :                 state->lens[order[state->have++]] = 0;

  00b11	0f b7 04 45 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflate@@9@9[eax*2]
  00b19	33 d2		 xor	 edx, edx
  00b1b	66 89 54 41 74	 mov	 WORD PTR [ecx+eax*2+116], dx
  00b20	8b 41 6c	 mov	 eax, DWORD PTR [ecx+108]
  00b23	40		 inc	 eax
  00b24	89 41 6c	 mov	 DWORD PTR [ecx+108], eax
  00b27	83 f8 13	 cmp	 eax, 19			; 00000013H
  00b2a	72 e5		 jb	 SHORT $LL183@inflate
$LN184@inflate:

; 925  :             state->next = state->codes;

  00b2c	8d 81 34 05 00
	00		 lea	 eax, DWORD PTR [ecx+1332]

; 926  :             state->lencode = (const code FAR *)(state->next);
; 927  :             state->lenbits = 7;

  00b32	c7 41 58 07 00
	00 00		 mov	 DWORD PTR [ecx+88], 7
  00b39	8d 51 70	 lea	 edx, DWORD PTR [ecx+112]
  00b3c	89 41 50	 mov	 DWORD PTR [ecx+80], eax
  00b3f	89 02		 mov	 DWORD PTR [edx], eax
  00b41	83 c1 58	 add	 ecx, 88			; 00000058H

; 928  :             ret = inflate_table(CODES, state->lens, 19, &(state->next),

  00b44	8b 45 f0	 mov	 eax, DWORD PTR _state$1$[ebp]
  00b47	05 f4 02 00 00	 add	 eax, 756		; 000002f4H
  00b4c	50		 push	 eax
  00b4d	51		 push	 ecx
  00b4e	52		 push	 edx
  00b4f	8b 55 f0	 mov	 edx, DWORD PTR _state$1$[ebp]
  00b52	33 c9		 xor	 ecx, ecx
  00b54	6a 13		 push	 19			; 00000013H
  00b56	8d 52 74	 lea	 edx, DWORD PTR [edx+116]
  00b59	e8 00 00 00 00	 call	 _inflate_table

; 929  :                                 &(state->lenbits), state->work);
; 930  :             if (ret) {

  00b5e	8b 4d f0	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00b61	83 c4 10	 add	 esp, 16			; 00000010H
  00b64	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00b67	89 45 d0	 mov	 DWORD PTR _ret$1$[ebp], eax
  00b6a	85 c0		 test	 eax, eax
  00b6c	74 21		 je	 SHORT $LN429@inflate

; 931  :                 strm->msg = (char *)"invalid code lengths set";

  00b6e	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00b71	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set@

; 932  :                 state->mode = BAD;
; 933  :                 break;

  00b78	e9 12 0a 00 00	 jmp	 $LN1111@inflate
$LN426@inflate:

; 908  :                 strm->msg = (char *)"too many length or distance symbols";

  00b7d	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]

; 909  :                 state->mode = BAD;

  00b80	8b 4d f0	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00b83	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5sym@

; 910  :                 break;

  00b8a	e9 00 0a 00 00	 jmp	 $LN1111@inflate
$LN429@inflate:

; 934  :             }
; 935  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 936  :             state->have = 0;

  00b8f	c7 41 6c 00 00
	00 00		 mov	 DWORD PTR [ecx+108], 0

; 937  :             state->mode = CODELENS;

  00b96	c7 41 04 46 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16198 ; 00003f46H
$LN536@inflate:

; 938  :                 /* fallthrough */
; 939  :         case CODELENS:
; 940  :             while (state->have < state->nlen + state->ndist) {

  00b9d	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]
  00ba0	03 41 64	 add	 eax, DWORD PTR [ecx+100]
  00ba3	39 41 6c	 cmp	 DWORD PTR [ecx+108], eax
  00ba6	0f 83 5f 02 00
	00		 jae	 $LN910@inflate
  00bac	0f 1f 40 00	 npad	 4
$LL185@inflate:

; 941  :                 for (;;) {
; 942  :                     here = state->lencode[BITS(state->lenbits)];

  00bb0	8b 41 50	 mov	 eax, DWORD PTR [ecx+80]
  00bb3	8b 79 58	 mov	 edi, DWORD PTR [ecx+88]
  00bb6	8b cf		 mov	 ecx, edi
  00bb8	89 45 c8	 mov	 DWORD PTR $T6[ebp], eax
  00bbb	b8 01 00 00 00	 mov	 eax, 1
  00bc0	d3 e0		 shl	 eax, cl
  00bc2	8b 4d c8	 mov	 ecx, DWORD PTR $T6[ebp]
  00bc5	48		 dec	 eax
  00bc6	23 c2		 and	 eax, edx
  00bc8	89 7d bc	 mov	 DWORD PTR $T1[ebp], edi
  00bcb	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00bce	8b c8		 mov	 ecx, eax
  00bd0	c1 e9 08	 shr	 ecx, 8
  00bd3	8b f8		 mov	 edi, eax
  00bd5	c1 ef 10	 shr	 edi, 16			; 00000010H
  00bd8	89 4d d4	 mov	 DWORD PTR tv4741[ebp], ecx
  00bdb	0f b6 c9	 movzx	 ecx, cl
  00bde	89 7d cc	 mov	 DWORD PTR $T13[ebp], edi

; 943  :                     if ((unsigned)(here.bits) <= bits) break;

  00be1	8b 7d ec	 mov	 edi, DWORD PTR _next$1$[ebp]
  00be4	3b ce		 cmp	 ecx, esi
  00be6	76 56		 jbe	 SHORT $LN908@inflate
$LL187@inflate:

; 944  :                     PULLBYTE();

  00be8	85 db		 test	 ebx, ebx
  00bea	0f 84 ea f9 ff
	ff		 je	 $LN905@inflate
  00bf0	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00bf3	8b ce		 mov	 ecx, esi
  00bf5	d3 e0		 shl	 eax, cl
  00bf7	4b		 dec	 ebx
  00bf8	8b 4d bc	 mov	 ecx, DWORD PTR $T1[ebp]
  00bfb	03 d0		 add	 edx, eax
  00bfd	b8 01 00 00 00	 mov	 eax, 1
  00c02	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00c05	d3 e0		 shl	 eax, cl
  00c07	47		 inc	 edi
  00c08	8b 4d c8	 mov	 ecx, DWORD PTR $T6[ebp]
  00c0b	48		 dec	 eax
  00c0c	23 c2		 and	 eax, edx
  00c0e	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00c11	83 c6 08	 add	 esi, 8
  00c14	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  00c17	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00c1a	8b c8		 mov	 ecx, eax
  00c1c	c1 e9 08	 shr	 ecx, 8
  00c1f	89 4d d4	 mov	 DWORD PTR tv4751[ebp], ecx
  00c22	89 45 cc	 mov	 DWORD PTR tv4943[ebp], eax
  00c25	c1 6d cc 10	 shr	 DWORD PTR tv4943[ebp], 16 ; 00000010H
  00c29	0f b6 c9	 movzx	 ecx, cl
  00c2c	3b ce		 cmp	 ecx, esi
  00c2e	77 b8		 ja	 SHORT $LL187@inflate

; 943  :                     if ((unsigned)(here.bits) <= bits) break;

  00c30	8b 4d cc	 mov	 ecx, DWORD PTR tv4943[ebp]
  00c33	0f b7 c9	 movzx	 ecx, cx
  00c36	89 4d cc	 mov	 DWORD PTR $T13[ebp], ecx
  00c39	8a 4d d4	 mov	 cl, BYTE PTR tv4751[ebp]
  00c3c	eb 03		 jmp	 SHORT $LN563@inflate
$LN908@inflate:
  00c3e	8b 4d d4	 mov	 ecx, DWORD PTR tv4741[ebp]
$LN563@inflate:

; 945  :                 }
; 946  :                 if (here.val < 16) {

  00c41	8b 5d cc	 mov	 ebx, DWORD PTR $T13[ebp]
  00c44	66 83 fb 10	 cmp	 bx, 16			; 00000010H
  00c48	0f b7 fb	 movzx	 edi, bx
  00c4b	89 7d c8	 mov	 DWORD PTR tv4945[ebp], edi
  00c4e	0f b7 fb	 movzx	 edi, bx
  00c51	8b 5d f4	 mov	 ebx, DWORD PTR _have$1$[ebp]
  00c54	89 7d bc	 mov	 DWORD PTR tv4944[ebp], edi
  00c57	8b 7d ec	 mov	 edi, DWORD PTR _next$1$[ebp]
  00c5a	73 30		 jae	 SHORT $LN433@inflate

; 947  :                     DROPBITS(here.bits);
; 948  :                     state->lens[state->have++] = here.val;

  00c5c	8b 7d f0	 mov	 edi, DWORD PTR _state$1$[ebp]
  00c5f	d3 ea		 shr	 edx, cl
  00c61	8b c8		 mov	 ecx, eax
  00c63	c1 e9 08	 shr	 ecx, 8
  00c66	0f b6 c9	 movzx	 ecx, cl
  00c69	2b f1		 sub	 esi, ecx
  00c6b	c1 e8 10	 shr	 eax, 16			; 00000010H
  00c6e	8b 4d f0	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00c71	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00c74	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  00c77	8b 49 6c	 mov	 ecx, DWORD PTR [ecx+108]
  00c7a	66 89 44 4f 74	 mov	 WORD PTR [edi+ecx*2+116], ax
  00c7f	8b cf		 mov	 ecx, edi
  00c81	ff 41 6c	 inc	 DWORD PTR [ecx+108]
  00c84	8b 41 6c	 mov	 eax, DWORD PTR [ecx+108]

; 949  :                 }

  00c87	e9 6a 01 00 00	 jmp	 $LN1112@inflate
$LN433@inflate:

; 950  :                 else {
; 951  :                     if (here.val == 16) {

  00c8c	66 83 7d bc 10	 cmp	 WORD PTR tv4944[ebp], 16 ; 00000010H
  00c91	0f b6 c9	 movzx	 ecx, cl
  00c94	75 6a		 jne	 SHORT $LN435@inflate

; 952  :                         NEEDBITS(here.bits + 2);

  00c96	83 c1 02	 add	 ecx, 2
  00c99	89 4d bc	 mov	 DWORD PTR tv4996[ebp], ecx
  00c9c	3b f1		 cmp	 esi, ecx
  00c9e	73 25		 jae	 SHORT $LN196@inflate
$LL199@inflate:
  00ca0	85 db		 test	 ebx, ebx
  00ca2	0f 84 32 f9 ff
	ff		 je	 $LN905@inflate
  00ca8	0f b6 17	 movzx	 edx, BYTE PTR [edi]
  00cab	8b ce		 mov	 ecx, esi
  00cad	d3 e2		 shl	 edx, cl
  00caf	4b		 dec	 ebx
  00cb0	01 55 f8	 add	 DWORD PTR _hold$1$[ebp], edx
  00cb3	47		 inc	 edi
  00cb4	83 c6 08	 add	 esi, 8
  00cb7	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00cba	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  00cbd	3b 75 bc	 cmp	 esi, DWORD PTR tv4996[ebp]
  00cc0	72 de		 jb	 SHORT $LL199@inflate
  00cc2	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN196@inflate:

; 953  :                         DROPBITS(here.bits);

  00cc5	0f b6 cc	 movzx	 ecx, ah
  00cc8	d3 ea		 shr	 edx, cl
  00cca	2b f1		 sub	 esi, ecx

; 954  :                         if (state->have == 0) {

  00ccc	8b 4d f0	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00ccf	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00cd2	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  00cd5	83 79 6c 00	 cmp	 DWORD PTR [ecx+108], 0
  00cd9	0f 84 52 01 00
	00		 je	 $LN568@inflate

; 955  :                             strm->msg = (char *)"invalid bit length repeat";
; 956  :                             state->mode = BAD;
; 957  :                             break;
; 958  :                         }
; 959  :                         len = state->lens[state->have - 1];
; 960  :                         copy = 3 + BITS(2);

  00cdf	8b c2		 mov	 eax, edx

; 961  :                         DROPBITS(2);

  00ce1	c1 ea 02	 shr	 edx, 2
  00ce4	83 e0 03	 and	 eax, 3
  00ce7	83 c0 03	 add	 eax, 3
  00cea	83 ee 02	 sub	 esi, 2
  00ced	89 45 cc	 mov	 DWORD PTR _copy$6$[ebp], eax
  00cf0	8b 41 6c	 mov	 eax, DWORD PTR [ecx+108]
  00cf3	0f b7 44 41 72	 movzx	 eax, WORD PTR [ecx+eax*2+114]
  00cf8	89 45 c8	 mov	 DWORD PTR $T10[ebp], eax

; 962  :                     }

  00cfb	e9 ab 00 00 00	 jmp	 $LN1113@inflate
$LN435@inflate:

; 963  :                     else if (here.val == 17) {

  00d00	66 83 7d c8 11	 cmp	 WORD PTR tv4945[ebp], 17 ; 00000011H
  00d05	75 49		 jne	 SHORT $LN226@inflate

; 964  :                         NEEDBITS(here.bits + 3);

  00d07	83 c1 03	 add	 ecx, 3
  00d0a	89 4d bc	 mov	 DWORD PTR tv4952[ebp], ecx
  00d0d	3b f1		 cmp	 esi, ecx
  00d0f	73 25		 jae	 SHORT $LN210@inflate
$LL213@inflate:
  00d11	85 db		 test	 ebx, ebx
  00d13	0f 84 c1 f8 ff
	ff		 je	 $LN905@inflate
  00d19	0f b6 17	 movzx	 edx, BYTE PTR [edi]
  00d1c	8b ce		 mov	 ecx, esi
  00d1e	d3 e2		 shl	 edx, cl
  00d20	4b		 dec	 ebx
  00d21	01 55 f8	 add	 DWORD PTR _hold$1$[ebp], edx
  00d24	47		 inc	 edi
  00d25	83 c6 08	 add	 esi, 8
  00d28	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00d2b	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  00d2e	3b 75 bc	 cmp	 esi, DWORD PTR tv4952[ebp]
  00d31	72 de		 jb	 SHORT $LL213@inflate
  00d33	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN210@inflate:

; 965  :                         DROPBITS(here.bits);

  00d36	0f b6 cc	 movzx	 ecx, ah
  00d39	d3 ea		 shr	 edx, cl

; 966  :                         len = 0;
; 967  :                         copy = 3 + BITS(3);

  00d3b	8b c2		 mov	 eax, edx
  00d3d	83 e0 07	 and	 eax, 7
  00d40	83 c0 03	 add	 eax, 3

; 968  :                         DROPBITS(3);

  00d43	c1 ea 03	 shr	 edx, 3
  00d46	89 45 cc	 mov	 DWORD PTR _copy$6$[ebp], eax
  00d49	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH

; 969  :                     }

  00d4e	eb 4d		 jmp	 SHORT $LN1114@inflate
$LN226@inflate:

; 970  :                     else {
; 971  :                         NEEDBITS(here.bits + 7);

  00d50	83 c1 07	 add	 ecx, 7
  00d53	89 4d bc	 mov	 DWORD PTR tv4951[ebp], ecx
  00d56	3b f1		 cmp	 esi, ecx
  00d58	73 2b		 jae	 SHORT $LN224@inflate
  00d5a	66 0f 1f 44 00
	00		 npad	 6
$LL227@inflate:
  00d60	85 db		 test	 ebx, ebx
  00d62	0f 84 72 f8 ff
	ff		 je	 $LN905@inflate
  00d68	0f b6 17	 movzx	 edx, BYTE PTR [edi]
  00d6b	8b ce		 mov	 ecx, esi
  00d6d	d3 e2		 shl	 edx, cl
  00d6f	4b		 dec	 ebx
  00d70	01 55 f8	 add	 DWORD PTR _hold$1$[ebp], edx
  00d73	47		 inc	 edi
  00d74	83 c6 08	 add	 esi, 8
  00d77	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00d7a	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  00d7d	3b 75 bc	 cmp	 esi, DWORD PTR tv4951[ebp]
  00d80	72 de		 jb	 SHORT $LL227@inflate
  00d82	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN224@inflate:

; 972  :                         DROPBITS(here.bits);

  00d85	0f b6 cc	 movzx	 ecx, ah
  00d88	d3 ea		 shr	 edx, cl

; 973  :                         len = 0;
; 974  :                         copy = 11 + BITS(7);

  00d8a	8b c2		 mov	 eax, edx
  00d8c	83 e0 7f	 and	 eax, 127		; 0000007fH
  00d8f	83 c0 0b	 add	 eax, 11			; 0000000bH

; 975  :                         DROPBITS(7);

  00d92	c1 ea 07	 shr	 edx, 7
  00d95	89 45 cc	 mov	 DWORD PTR _copy$6$[ebp], eax
  00d98	b8 f9 ff ff ff	 mov	 eax, -7			; fffffff9H
$LN1114@inflate:

; 976  :                     }
; 977  :                     if (state->have + copy > state->nlen + state->ndist) {

  00d9d	2b c1		 sub	 eax, ecx
  00d9f	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR $T10[ebp], 0
  00da6	8b 4d f0	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00da9	03 f0		 add	 esi, eax
$LN1113@inflate:
  00dab	8b 41 6c	 mov	 eax, DWORD PTR [ecx+108]
  00dae	8b 49 68	 mov	 ecx, DWORD PTR [ecx+104]
  00db1	8b 5d f4	 mov	 ebx, DWORD PTR _have$1$[ebp]
  00db4	89 45 d4	 mov	 DWORD PTR $T16[ebp], eax
  00db7	8b 45 f0	 mov	 eax, DWORD PTR _state$1$[ebp]
  00dba	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00dbd	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  00dc0	03 48 64	 add	 ecx, DWORD PTR [eax+100]
  00dc3	8b 45 cc	 mov	 eax, DWORD PTR _copy$6$[ebp]
  00dc6	03 45 d4	 add	 eax, DWORD PTR $T16[ebp]
  00dc9	3b c1		 cmp	 eax, ecx
  00dcb	8b 4d f0	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00dce	77 61		 ja	 SHORT $LN568@inflate
  00dd0	8b 7d cc	 mov	 edi, DWORD PTR _copy$6$[ebp]
  00dd3	8b 45 d4	 mov	 eax, DWORD PTR $T16[ebp]
  00dd6	8b 5d c8	 mov	 ebx, DWORD PTR $T10[ebp]
  00dd9	0f 1f 80 00 00
	00 00		 npad	 7
$LL238@inflate:

; 978  :                         strm->msg = (char *)"invalid bit length repeat";
; 979  :                         state->mode = BAD;
; 980  :                         break;
; 981  :                     }
; 982  :                     while (copy--)
; 983  :                         state->lens[state->have++] = (unsigned short)len;

  00de0	66 89 5c 41 74	 mov	 WORD PTR [ecx+eax*2+116], bx
  00de5	8b 41 6c	 mov	 eax, DWORD PTR [ecx+108]
  00de8	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00deb	89 41 6c	 mov	 DWORD PTR [ecx+108], eax
  00dee	83 ef 01	 sub	 edi, 1
  00df1	75 ed		 jne	 SHORT $LL238@inflate
  00df3	8b 5d f4	 mov	 ebx, DWORD PTR _have$1$[ebp]
$LN1112@inflate:

; 938  :                 /* fallthrough */
; 939  :         case CODELENS:
; 940  :             while (state->have < state->nlen + state->ndist) {

  00df6	8b 7d ec	 mov	 edi, DWORD PTR _next$1$[ebp]
  00df9	89 45 d4	 mov	 DWORD PTR $T16[ebp], eax
  00dfc	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]
  00dff	03 41 64	 add	 eax, DWORD PTR [ecx+100]
  00e02	39 45 d4	 cmp	 DWORD PTR $T16[ebp], eax
  00e05	0f 82 a5 fd ff
	ff		 jb	 $LL185@inflate
$LN910@inflate:

; 984  :                 }
; 985  :             }
; 986  : 
; 987  :             /* handle error breaks in while */
; 988  :             if (state->mode == BAD) break;

  00e0b	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
$LN186@inflate:
  00e0e	81 79 04 51 3f
	00 00		 cmp	 DWORD PTR [ecx+4], 16209 ; 00003f51H
  00e15	0f 84 7b 07 00
	00		 je	 $LN8@inflate

; 989  : 
; 990  :             /* check for end-of-block code (better have one) */
; 991  :             if (state->lens[256] == 0) {

  00e1b	66 83 b9 74 02
	00 00 00	 cmp	 WORD PTR [ecx+628], 0
  00e23	75 1f		 jne	 SHORT $LN445@inflate

; 992  :                 strm->msg = (char *)"invalid code -- missing end-of-block";

  00e25	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9@

; 993  :                 state->mode = BAD;
; 994  :                 break;

  00e2c	e9 5e 07 00 00	 jmp	 $LN1111@inflate
$LN568@inflate:

; 984  :                 }
; 985  :             }
; 986  : 
; 987  :             /* handle error breaks in while */
; 988  :             if (state->mode == BAD) break;

  00e31	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00e34	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat@
  00e3b	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
  00e42	eb ca		 jmp	 SHORT $LN186@inflate
$LN445@inflate:

; 995  :             }
; 996  : 
; 997  :             /* build code tables -- note: do not change the lenbits or distbits
; 998  :                values here (9 and 6) without reading the comments in inftrees.h
; 999  :                concerning the ENOUGH constants, which depend on those values */
; 1000 :             state->next = state->codes;

  00e44	8d 51 70	 lea	 edx, DWORD PTR [ecx+112]

; 1001 :             state->lencode = (const code FAR *)(state->next);
; 1002 :             state->lenbits = 9;

  00e47	c7 41 58 09 00
	00 00		 mov	 DWORD PTR [ecx+88], 9
  00e4e	8d 81 34 05 00
	00		 lea	 eax, DWORD PTR [ecx+1332]
  00e54	89 55 bc	 mov	 DWORD PTR tv5161[ebp], edx

; 1003 :             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),

  00e57	8d b9 f4 02 00
	00		 lea	 edi, DWORD PTR [ecx+756]
  00e5d	89 02		 mov	 DWORD PTR [edx], eax
  00e5f	89 41 50	 mov	 DWORD PTR [ecx+80], eax
  00e62	8d 41 58	 lea	 eax, DWORD PTR [ecx+88]
  00e65	57		 push	 edi
  00e66	50		 push	 eax
  00e67	52		 push	 edx
  00e68	ff 71 64	 push	 DWORD PTR [ecx+100]
  00e6b	8d 51 74	 lea	 edx, DWORD PTR [ecx+116]
  00e6e	89 7d c8	 mov	 DWORD PTR tv5005[ebp], edi
  00e71	b9 01 00 00 00	 mov	 ecx, 1
  00e76	e8 00 00 00 00	 call	 _inflate_table

; 1004 :                                 &(state->lenbits), state->work);
; 1005 :             if (ret) {

  00e7b	8b 7d ec	 mov	 edi, DWORD PTR _next$1$[ebp]
  00e7e	83 c4 10	 add	 esp, 16			; 00000010H
  00e81	8b 4d f0	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00e84	89 45 d0	 mov	 DWORD PTR _ret$1$[ebp], eax
  00e87	85 c0		 test	 eax, eax
  00e89	74 12		 je	 SHORT $LN446@inflate

; 1006 :                 strm->msg = (char *)"invalid literal/lengths set";

  00e8b	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]

; 1007 :                 state->mode = BAD;
; 1008 :                 break;

  00e8e	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00e91	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set@
  00e98	e9 f2 06 00 00	 jmp	 $LN1111@inflate
$LN446@inflate:

; 1009 :             }
; 1010 :             state->distcode = (const code FAR *)(state->next);

  00e9d	8b 55 bc	 mov	 edx, DWORD PTR tv5161[ebp]

; 1011 :             state->distbits = 6;
; 1012 :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,

  00ea0	ff 75 c8	 push	 DWORD PTR tv5005[ebp]
  00ea3	c7 41 5c 06 00
	00 00		 mov	 DWORD PTR [ecx+92], 6
  00eaa	8b 02		 mov	 eax, DWORD PTR [edx]
  00eac	89 41 54	 mov	 DWORD PTR [ecx+84], eax
  00eaf	8d 41 5c	 lea	 eax, DWORD PTR [ecx+92]
  00eb2	50		 push	 eax
  00eb3	8b 41 64	 mov	 eax, DWORD PTR [ecx+100]
  00eb6	52		 push	 edx
  00eb7	ff 71 68	 push	 DWORD PTR [ecx+104]
  00eba	83 c1 74	 add	 ecx, 116		; 00000074H
  00ebd	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00ec0	b9 02 00 00 00	 mov	 ecx, 2
  00ec5	e8 00 00 00 00	 call	 _inflate_table

; 1013 :                             &(state->next), &(state->distbits), state->work);
; 1014 :             if (ret) {

  00eca	8b 4d f0	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00ecd	83 c4 10	 add	 esp, 16			; 00000010H
  00ed0	89 45 d0	 mov	 DWORD PTR _ret$1$[ebp], eax
  00ed3	85 c0		 test	 eax, eax
  00ed5	74 12		 je	 SHORT $LN447@inflate

; 1015 :                 strm->msg = (char *)"invalid distances set";

  00ed7	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]

; 1016 :                 state->mode = BAD;
; 1017 :                 break;

  00eda	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00edd	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BG@GMDFCBGP@invalid?5distances?5set@
  00ee4	e9 a6 06 00 00	 jmp	 $LN1111@inflate
$LN447@inflate:

; 1018 :             }
; 1019 :             Tracev((stderr, "inflate:       codes ok\n"));
; 1020 :             state->mode = LEN_;
; 1021 :             if (flush == Z_TREES) goto inf_leave;

  00ee9	8b 55 0c	 mov	 edx, DWORD PTR _flush$[ebp]
  00eec	c7 41 04 47 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16199 ; 00003f47H
  00ef3	83 fa 06	 cmp	 edx, 6
  00ef6	0f 84 09 07 00
	00		 je	 $LN881@inflate
  00efc	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN448@inflate:

; 1022 :                 /* fallthrough */
; 1023 :         case LEN_:
; 1024 :             state->mode = LEN;

  00eff	c7 41 04 48 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16200 ; 00003f48H
$LN450@inflate:

; 1025 :                 /* fallthrough */
; 1026 :         case LEN:
; 1027 :             if (have >= 6 && left >= 258) {

  00f06	83 fb 06	 cmp	 ebx, 6
  00f09	0f 82 79 00 00
	00		 jb	 $LN451@inflate
  00f0f	81 7d e4 02 01
	00 00		 cmp	 DWORD PTR _left$1$[ebp], 258 ; 00000102H
  00f16	72 70		 jb	 SHORT $LN451@inflate

; 1028 :                 RESTORE();

  00f18	8b 7d c4	 mov	 edi, DWORD PTR $T2[ebp]
  00f1b	8b 45 dc	 mov	 eax, DWORD PTR _put$1$[ebp]
  00f1e	89 07		 mov	 DWORD PTR [edi], eax
  00f20	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00f23	8b 7d e4	 mov	 edi, DWORD PTR _left$1$[ebp]
  00f26	89 78 10	 mov	 DWORD PTR [eax+16], edi
  00f29	8b 7d ec	 mov	 edi, DWORD PTR _next$1$[ebp]
  00f2c	89 38		 mov	 DWORD PTR [eax], edi
  00f2e	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  00f31	89 51 3c	 mov	 DWORD PTR [ecx+60], edx

; 1029 :                 inflate_fast(strm, out);

  00f34	8b 55 d8	 mov	 edx, DWORD PTR _out$1$[ebp]
  00f37	89 71 40	 mov	 DWORD PTR [ecx+64], esi
  00f3a	8b c8		 mov	 ecx, eax
  00f3c	e8 00 00 00 00	 call	 _inflate_fast

; 1030 :                 LOAD();

  00f41	8b 4d c4	 mov	 ecx, DWORD PTR $T2[ebp]
  00f44	8b 01		 mov	 eax, DWORD PTR [ecx]
  00f46	89 45 dc	 mov	 DWORD PTR _put$1$[ebp], eax
  00f49	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00f4c	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00f4f	8b 38		 mov	 edi, DWORD PTR [eax]
  00f51	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]
  00f54	89 4d e4	 mov	 DWORD PTR _left$1$[ebp], ecx
  00f57	8b 4d f0	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00f5a	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  00f5d	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx

; 1031 :                 if (state->mode == TYPE)

  00f60	81 79 04 3f 3f
	00 00		 cmp	 DWORD PTR [ecx+4], 16191 ; 00003f3fH
  00f67	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  00f6a	8b 71 40	 mov	 esi, DWORD PTR [ecx+64]
  00f6d	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00f70	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  00f73	0f 85 1d 06 00
	00		 jne	 $LN8@inflate

; 1032 :                     state->back = -1;

  00f79	c7 81 c8 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+7112], -1

; 1033 :                 break;

  00f83	e9 0e 06 00 00	 jmp	 $LN8@inflate
$LN451@inflate:

; 1034 :             }
; 1035 :             state->back = 0;
; 1036 :             for (;;) {
; 1037 :                 here = state->lencode[BITS(state->lenbits)];

  00f88	8b 41 58	 mov	 eax, DWORD PTR [ecx+88]
  00f8b	89 45 c8	 mov	 DWORD PTR $T5[ebp], eax
  00f8e	8b 41 50	 mov	 eax, DWORD PTR [ecx+80]
  00f91	89 45 d4	 mov	 DWORD PTR $T15[ebp], eax
  00f94	b8 01 00 00 00	 mov	 eax, 1
  00f99	c7 81 c8 1b 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+7112], 0
  00fa3	8b 4d c8	 mov	 ecx, DWORD PTR $T5[ebp]
  00fa6	d3 e0		 shl	 eax, cl
  00fa8	8b 4d d4	 mov	 ecx, DWORD PTR $T15[ebp]
  00fab	48		 dec	 eax
  00fac	23 c2		 and	 eax, edx
  00fae	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00fb1	8b c8		 mov	 ecx, eax
  00fb3	c1 e9 08	 shr	 ecx, 8
  00fb6	0f b6 c9	 movzx	 ecx, cl

; 1038 :                 if ((unsigned)(here.bits) <= bits) break;

  00fb9	3b ce		 cmp	 ecx, esi
  00fbb	76 44		 jbe	 SHORT $LN570@inflate

; 970  :                     else {
; 971  :                         NEEDBITS(here.bits + 7);

  00fbd	8b 45 d4	 mov	 eax, DWORD PTR $T15[ebp]
  00fc0	89 45 d4	 mov	 DWORD PTR $T15[ebp], eax
$LL246@inflate:

; 1039 :                 PULLBYTE();

  00fc3	85 db		 test	 ebx, ebx
  00fc5	0f 84 0f f6 ff
	ff		 je	 $LN905@inflate
  00fcb	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00fce	8b ce		 mov	 ecx, esi
  00fd0	d3 e0		 shl	 eax, cl
  00fd2	4b		 dec	 ebx
  00fd3	8b 4d c8	 mov	 ecx, DWORD PTR $T5[ebp]
  00fd6	03 d0		 add	 edx, eax
  00fd8	b8 01 00 00 00	 mov	 eax, 1
  00fdd	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00fe0	d3 e0		 shl	 eax, cl
  00fe2	47		 inc	 edi
  00fe3	8b 4d d4	 mov	 ecx, DWORD PTR $T15[ebp]
  00fe6	48		 dec	 eax
  00fe7	23 c2		 and	 eax, edx
  00fe9	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00fec	83 c6 08	 add	 esi, 8
  00fef	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  00ff2	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00ff5	8b c8		 mov	 ecx, eax
  00ff7	c1 e9 08	 shr	 ecx, 8
  00ffa	0f b6 c9	 movzx	 ecx, cl
  00ffd	3b ce		 cmp	 ecx, esi
  00fff	77 c2		 ja	 SHORT $LL246@inflate
$LN570@inflate:

; 1040 :             }
; 1041 :             if (here.op && (here.op & 0xf0) == 0) {

  01001	84 c0		 test	 al, al
  01003	0f 84 b2 00 00
	00		 je	 $LN263@inflate
  01009	a8 f0		 test	 al, 240			; 000000f0H
  0100b	0f 85 aa 00 00
	00		 jne	 $LN263@inflate

; 1042 :                 last = here;
; 1043 :                 for (;;) {
; 1044 :                     here = state->lencode[last.val +

  01011	8b c8		 mov	 ecx, eax
  01013	bf 01 00 00 00	 mov	 edi, 1
  01018	c1 e9 08	 shr	 ecx, 8
  0101b	8b d0		 mov	 edx, eax
  0101d	0f b6 d9	 movzx	 ebx, cl
  01020	0f b6 c8	 movzx	 ecx, al
  01023	03 cb		 add	 ecx, ebx
  01025	c1 e8 10	 shr	 eax, 16			; 00000010H
  01028	d3 e7		 shl	 edi, cl
  0102a	8b cb		 mov	 ecx, ebx
  0102c	4f		 dec	 edi
  0102d	89 55 c8	 mov	 DWORD PTR _last$[ebp], edx
  01030	23 7d f8	 and	 edi, DWORD PTR _hold$1$[ebp]
  01033	d3 ef		 shr	 edi, cl
  01035	8b 4d d4	 mov	 ecx, DWORD PTR $T15[ebp]
  01038	03 f8		 add	 edi, eax
  0103a	8b 04 b9	 mov	 eax, DWORD PTR [ecx+edi*4]
  0103d	8b c8		 mov	 ecx, eax
  0103f	c1 e9 08	 shr	 ecx, 8

; 1045 :                             (BITS(last.bits + last.op) >> last.bits)];
; 1046 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  01042	0f b6 c9	 movzx	 ecx, cl
  01045	03 cb		 add	 ecx, ebx
  01047	3b ce		 cmp	 ecx, esi
  01049	76 59		 jbe	 SHORT $LN260@inflate
  0104b	0f 1f 44 00 00	 npad	 5
$LL252@inflate:

; 1047 :                     PULLBYTE();

  01050	8b 45 f4	 mov	 eax, DWORD PTR _have$1$[ebp]
  01053	85 c0		 test	 eax, eax
  01055	0f 84 82 f5 ff
	ff		 je	 $LN915@inflate
  0105b	8b 5d ec	 mov	 ebx, DWORD PTR _next$1$[ebp]
  0105e	48		 dec	 eax
  0105f	89 45 f4	 mov	 DWORD PTR _have$1$[ebp], eax
  01062	8b ce		 mov	 ecx, esi
  01064	bf 01 00 00 00	 mov	 edi, 1
  01069	83 c6 08	 add	 esi, 8
  0106c	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  0106f	43		 inc	 ebx
  01070	d3 e0		 shl	 eax, cl
  01072	01 45 f8	 add	 DWORD PTR _hold$1$[ebp], eax
  01075	0f b7 45 ca	 movzx	 eax, WORD PTR _last$[ebp+2]
  01079	89 5d ec	 mov	 DWORD PTR _next$1$[ebp], ebx
  0107c	0f b6 de	 movzx	 ebx, dh
  0107f	0f b6 ca	 movzx	 ecx, dl
  01082	03 cb		 add	 ecx, ebx
  01084	d3 e7		 shl	 edi, cl
  01086	8b cb		 mov	 ecx, ebx
  01088	4f		 dec	 edi
  01089	23 7d f8	 and	 edi, DWORD PTR _hold$1$[ebp]
  0108c	d3 ef		 shr	 edi, cl
  0108e	03 f8		 add	 edi, eax
  01090	8b 45 d4	 mov	 eax, DWORD PTR $T15[ebp]
  01093	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  01096	8b c8		 mov	 ecx, eax
  01098	c1 e9 08	 shr	 ecx, 8
  0109b	0f b6 c9	 movzx	 ecx, cl
  0109e	03 cb		 add	 ecx, ebx
  010a0	3b ce		 cmp	 ecx, esi
  010a2	77 ac		 ja	 SHORT $LL252@inflate
$LN260@inflate:
  010a4	8b 5d f4	 mov	 ebx, DWORD PTR _have$1$[ebp]
  010a7	8b 7d ec	 mov	 edi, DWORD PTR _next$1$[ebp]

; 1048 :                 }
; 1049 :                 DROPBITS(last.bits);

  010aa	0f b6 ce	 movzx	 ecx, dh

; 1050 :                 state->back += last.bits;

  010ad	8b 55 f0	 mov	 edx, DWORD PTR _state$1$[ebp]
  010b0	d3 6d f8	 shr	 DWORD PTR _hold$1$[ebp], cl
  010b3	2b f1		 sub	 esi, ecx
  010b5	89 8a c8 1b 00
	00		 mov	 DWORD PTR [edx+7112], ecx
$LN263@inflate:

; 1051 :             }
; 1052 :             DROPBITS(here.bits);

  010bb	8b c8		 mov	 ecx, eax
  010bd	c1 e9 08	 shr	 ecx, 8
  010c0	0f b6 d1	 movzx	 edx, cl
  010c3	8b ca		 mov	 ecx, edx
  010c5	2b f2		 sub	 esi, edx
  010c7	d3 6d f8	 shr	 DWORD PTR _hold$1$[ebp], cl

; 1053 :             state->back += here.bits;

  010ca	8b 4d f0	 mov	 ecx, DWORD PTR _state$1$[ebp]
  010cd	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  010d0	8b 89 c8 1b 00
	00		 mov	 ecx, DWORD PTR [ecx+7112]
  010d6	03 ca		 add	 ecx, edx
  010d8	8b 55 f0	 mov	 edx, DWORD PTR _state$1$[ebp]
  010db	89 8a c8 1b 00
	00		 mov	 DWORD PTR [edx+7112], ecx

; 1054 :             state->length = (unsigned)here.val;

  010e1	8b c8		 mov	 ecx, eax
  010e3	c1 e9 10	 shr	 ecx, 16			; 00000010H
  010e6	89 4a 44	 mov	 DWORD PTR [edx+68], ecx

; 1055 :             if ((int)(here.op) == 0) {

  010e9	8b ca		 mov	 ecx, edx
  010eb	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  010ee	84 c0		 test	 al, al
  010f0	75 0c		 jne	 SHORT $LN458@inflate

; 1056 :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 1057 :                         "inflate:         literal '%c'\n" :
; 1058 :                         "inflate:         literal 0x%02x\n", here.val));
; 1059 :                 state->mode = LIT;

  010f2	c7 41 04 4d 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16205 ; 00003f4dH

; 1060 :                 break;

  010f9	e9 98 04 00 00	 jmp	 $LN8@inflate
$LN458@inflate:

; 1061 :             }
; 1062 :             if (here.op & 32) {

  010fe	a8 20		 test	 al, 32			; 00000020H
  01100	74 16		 je	 SHORT $LN459@inflate

; 1063 :                 Tracevv((stderr, "inflate:         end of block\n"));
; 1064 :                 state->back = -1;

  01102	c7 81 c8 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+7112], -1
$LN419@inflate:

; 620  :     for (;;)
; 621  :         switch (state->mode) {

  0110c	c7 41 04 3f 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16191 ; 00003f3fH
  01113	e9 7e 04 00 00	 jmp	 $LN8@inflate
$LN459@inflate:

; 1065 :                 state->mode = TYPE;
; 1066 :                 break;
; 1067 :             }
; 1068 :             if (here.op & 64) {

  01118	a8 40		 test	 al, 64			; 00000040H
  0111a	74 0f		 je	 SHORT $LN460@inflate

; 1069 :                 strm->msg = (char *)"invalid literal/length code";

  0111c	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0111f	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code@

; 1070 :                 state->mode = BAD;
; 1071 :                 break;

  01126	e9 64 04 00 00	 jmp	 $LN1111@inflate
$LN460@inflate:

; 1072 :             }
; 1073 :             state->extra = (unsigned)(here.op) & 15;

  0112b	0f b6 c0	 movzx	 eax, al
  0112e	83 e0 0f	 and	 eax, 15			; 0000000fH

; 1074 :             state->mode = LENEXT;

  01131	c7 41 04 49 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16201 ; 00003f49H
  01138	89 41 4c	 mov	 DWORD PTR [ecx+76], eax
$LN461@inflate:

; 1075 :                 /* fallthrough */
; 1076 :         case LENEXT:
; 1077 :             if (state->extra) {

  0113b	8b 41 4c	 mov	 eax, DWORD PTR [ecx+76]
  0113e	89 45 cc	 mov	 DWORD PTR $T12[ebp], eax
  01141	85 c0		 test	 eax, eax
  01143	74 57		 je	 SHORT $LN725@inflate

; 1078 :                 NEEDBITS(state->extra);

  01145	3b f0		 cmp	 esi, eax
  01147	73 2b		 jae	 SHORT $LN264@inflate

; 1038 :                 if ((unsigned)(here.bits) <= bits) break;

  01149	89 45 cc	 mov	 DWORD PTR $T12[ebp], eax
  0114c	0f 1f 40 00	 npad	 4
$LL267@inflate:

; 1078 :                 NEEDBITS(state->extra);

  01150	85 db		 test	 ebx, ebx
  01152	0f 84 82 f4 ff
	ff		 je	 $LN905@inflate
  01158	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0115b	8b ce		 mov	 ecx, esi
  0115d	d3 e0		 shl	 eax, cl
  0115f	4b		 dec	 ebx
  01160	03 d0		 add	 edx, eax
  01162	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  01165	47		 inc	 edi
  01166	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  01169	83 c6 08	 add	 esi, 8
  0116c	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  0116f	3b 75 cc	 cmp	 esi, DWORD PTR $T12[ebp]
  01172	72 dc		 jb	 SHORT $LL267@inflate
$LN264@inflate:

; 1079 :                 state->length += BITS(state->extra);

  01174	8b 4d cc	 mov	 ecx, DWORD PTR $T12[ebp]
  01177	b8 01 00 00 00	 mov	 eax, 1
  0117c	d3 e0		 shl	 eax, cl
  0117e	8b 4d f0	 mov	 ecx, DWORD PTR _state$1$[ebp]
  01181	48		 dec	 eax
  01182	23 c2		 and	 eax, edx
  01184	01 41 44	 add	 DWORD PTR [ecx+68], eax

; 1080 :                 DROPBITS(state->extra);

  01187	8b 45 cc	 mov	 eax, DWORD PTR $T12[ebp]
  0118a	8b c8		 mov	 ecx, eax
  0118c	d3 ea		 shr	 edx, cl
  0118e	2b f0		 sub	 esi, eax

; 1081 :                 state->back += state->extra;

  01190	8b 4d f0	 mov	 ecx, DWORD PTR _state$1$[ebp]
  01193	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  01196	01 81 c8 1b 00
	00		 add	 DWORD PTR [ecx+7112], eax
$LN725@inflate:

; 1082 :             }
; 1083 :             Tracevv((stderr, "inflate:         length %u\n", state->length));
; 1084 :             state->was = state->length;

  0119c	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]
  0119f	89 81 cc 1b 00
	00		 mov	 DWORD PTR [ecx+7116], eax

; 1085 :             state->mode = DIST;

  011a5	c7 41 04 4a 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16202 ; 00003f4aH
$LN464@inflate:

; 1086 :                 /* fallthrough */
; 1087 :         case DIST:
; 1088 :             for (;;) {
; 1089 :                 here = state->distcode[BITS(state->distbits)];

  011ac	8b 41 5c	 mov	 eax, DWORD PTR [ecx+92]
  011af	89 45 c8	 mov	 DWORD PTR $T4[ebp], eax
  011b2	8b 41 54	 mov	 eax, DWORD PTR [ecx+84]
  011b5	8b 4d c8	 mov	 ecx, DWORD PTR $T4[ebp]
  011b8	89 45 d4	 mov	 DWORD PTR $T14[ebp], eax
  011bb	b8 01 00 00 00	 mov	 eax, 1
  011c0	d3 e0		 shl	 eax, cl
  011c2	8b 4d d4	 mov	 ecx, DWORD PTR $T14[ebp]
  011c5	48		 dec	 eax
  011c6	23 c2		 and	 eax, edx
  011c8	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  011cb	8b c8		 mov	 ecx, eax
  011cd	c1 e9 08	 shr	 ecx, 8
  011d0	0f b6 c9	 movzx	 ecx, cl

; 1090 :                 if ((unsigned)(here.bits) <= bits) break;

  011d3	3b ce		 cmp	 ecx, esi
  011d5	76 47		 jbe	 SHORT $LN575@inflate

; 1081 :                 state->back += state->extra;

  011d7	8b 45 d4	 mov	 eax, DWORD PTR $T14[ebp]
  011da	89 45 d4	 mov	 DWORD PTR $T14[ebp], eax
  011dd	0f 1f 00	 npad	 3
$LL275@inflate:

; 1091 :                 PULLBYTE();

  011e0	85 db		 test	 ebx, ebx
  011e2	0f 84 f2 f3 ff
	ff		 je	 $LN905@inflate
  011e8	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  011eb	8b ce		 mov	 ecx, esi
  011ed	d3 e0		 shl	 eax, cl
  011ef	4b		 dec	 ebx
  011f0	8b 4d c8	 mov	 ecx, DWORD PTR $T4[ebp]
  011f3	03 d0		 add	 edx, eax
  011f5	b8 01 00 00 00	 mov	 eax, 1
  011fa	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  011fd	d3 e0		 shl	 eax, cl
  011ff	47		 inc	 edi
  01200	8b 4d d4	 mov	 ecx, DWORD PTR $T14[ebp]
  01203	48		 dec	 eax
  01204	23 c2		 and	 eax, edx
  01206	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  01209	83 c6 08	 add	 esi, 8
  0120c	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  0120f	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  01212	8b c8		 mov	 ecx, eax
  01214	c1 e9 08	 shr	 ecx, 8
  01217	0f b6 c9	 movzx	 ecx, cl
  0121a	3b ce		 cmp	 ecx, esi
  0121c	77 c2		 ja	 SHORT $LL275@inflate
$LN575@inflate:

; 1092 :             }
; 1093 :             if ((here.op & 0xf0) == 0) {

  0121e	a8 f0		 test	 al, 240			; 000000f0H
  01220	0f 85 a3 00 00
	00		 jne	 $LN907@inflate

; 1094 :                 last = here;
; 1095 :                 for (;;) {
; 1096 :                     here = state->distcode[last.val +

  01226	8b c8		 mov	 ecx, eax
  01228	bf 01 00 00 00	 mov	 edi, 1
  0122d	c1 e9 08	 shr	 ecx, 8
  01230	8b d0		 mov	 edx, eax
  01232	0f b6 d9	 movzx	 ebx, cl
  01235	0f b6 c8	 movzx	 ecx, al
  01238	03 cb		 add	 ecx, ebx
  0123a	c1 e8 10	 shr	 eax, 16			; 00000010H
  0123d	d3 e7		 shl	 edi, cl
  0123f	8b cb		 mov	 ecx, ebx
  01241	4f		 dec	 edi
  01242	89 55 c8	 mov	 DWORD PTR _last$[ebp], edx
  01245	23 7d f8	 and	 edi, DWORD PTR _hold$1$[ebp]
  01248	d3 ef		 shr	 edi, cl
  0124a	8b 4d d4	 mov	 ecx, DWORD PTR $T14[ebp]
  0124d	03 f8		 add	 edi, eax
  0124f	8b 04 b9	 mov	 eax, DWORD PTR [ecx+edi*4]
  01252	8b c8		 mov	 ecx, eax
  01254	c1 e9 08	 shr	 ecx, 8

; 1097 :                             (BITS(last.bits + last.op) >> last.bits)];
; 1098 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  01257	0f b6 c9	 movzx	 ecx, cl
  0125a	03 cb		 add	 ecx, ebx
  0125c	3b ce		 cmp	 ecx, esi
  0125e	76 54		 jbe	 SHORT $LN289@inflate
$LL281@inflate:

; 1099 :                     PULLBYTE();

  01260	8b 45 f4	 mov	 eax, DWORD PTR _have$1$[ebp]
  01263	85 c0		 test	 eax, eax
  01265	0f 84 72 f3 ff
	ff		 je	 $LN915@inflate
  0126b	8b 5d ec	 mov	 ebx, DWORD PTR _next$1$[ebp]
  0126e	48		 dec	 eax
  0126f	89 45 f4	 mov	 DWORD PTR _have$1$[ebp], eax
  01272	8b ce		 mov	 ecx, esi
  01274	bf 01 00 00 00	 mov	 edi, 1
  01279	83 c6 08	 add	 esi, 8
  0127c	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  0127f	43		 inc	 ebx
  01280	d3 e0		 shl	 eax, cl
  01282	01 45 f8	 add	 DWORD PTR _hold$1$[ebp], eax
  01285	0f b7 45 ca	 movzx	 eax, WORD PTR _last$[ebp+2]
  01289	89 5d ec	 mov	 DWORD PTR _next$1$[ebp], ebx
  0128c	0f b6 de	 movzx	 ebx, dh
  0128f	0f b6 ca	 movzx	 ecx, dl
  01292	03 cb		 add	 ecx, ebx
  01294	d3 e7		 shl	 edi, cl
  01296	8b cb		 mov	 ecx, ebx
  01298	4f		 dec	 edi
  01299	23 7d f8	 and	 edi, DWORD PTR _hold$1$[ebp]
  0129c	d3 ef		 shr	 edi, cl
  0129e	03 f8		 add	 edi, eax
  012a0	8b 45 d4	 mov	 eax, DWORD PTR $T14[ebp]
  012a3	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  012a6	8b c8		 mov	 ecx, eax
  012a8	c1 e9 08	 shr	 ecx, 8
  012ab	0f b6 c9	 movzx	 ecx, cl
  012ae	03 cb		 add	 ecx, ebx
  012b0	3b ce		 cmp	 ecx, esi
  012b2	77 ac		 ja	 SHORT $LL281@inflate
$LN289@inflate:

; 1100 :                 }
; 1101 :                 DROPBITS(last.bits);
; 1102 :                 state->back += last.bits;

  012b4	8b 5d f0	 mov	 ebx, DWORD PTR _state$1$[ebp]
  012b7	0f b6 ce	 movzx	 ecx, dh
  012ba	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  012bd	2b f1		 sub	 esi, ecx
  012bf	d3 ea		 shr	 edx, cl
  012c1	01 8b c8 1b 00
	00		 add	 DWORD PTR [ebx+7112], ecx
  012c7	eb 03		 jmp	 SHORT $LN292@inflate
$LN907@inflate:

; 1092 :             }
; 1093 :             if ((here.op & 0xf0) == 0) {

  012c9	8b 5d f0	 mov	 ebx, DWORD PTR _state$1$[ebp]
$LN292@inflate:

; 1103 :             }
; 1104 :             DROPBITS(here.bits);
; 1105 :             state->back += here.bits;
; 1106 :             if (here.op & 64) {

  012cc	8b 7d ec	 mov	 edi, DWORD PTR _next$1$[ebp]
  012cf	8b c8		 mov	 ecx, eax
  012d1	c1 e9 08	 shr	 ecx, 8
  012d4	0f b6 c9	 movzx	 ecx, cl
  012d7	01 8b c8 1b 00
	00		 add	 DWORD PTR [ebx+7112], ecx
  012dd	2b f1		 sub	 esi, ecx
  012df	d3 ea		 shr	 edx, cl
  012e1	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  012e4	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  012e7	a8 40		 test	 al, 64			; 00000040H
  012e9	74 15		 je	 SHORT $LN470@inflate

; 1107 :                 strm->msg = (char *)"invalid distance code";

  012eb	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]

; 1108 :                 state->mode = BAD;

  012ee	8b 4d f0	 mov	 ecx, DWORD PTR _state$1$[ebp]

; 1109 :                 break;

  012f1	8b 5d f4	 mov	 ebx, DWORD PTR _have$1$[ebp]
  012f4	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BG@LBKINIKP@invalid?5distance?5code@
  012fb	e9 8f 02 00 00	 jmp	 $LN1111@inflate
$LN470@inflate:

; 1110 :             }
; 1111 :             state->offset = (unsigned)here.val;

  01300	8b c8		 mov	 ecx, eax

; 1112 :             state->extra = (unsigned)(here.op) & 15;

  01302	0f b6 c0	 movzx	 eax, al
  01305	c1 e9 10	 shr	 ecx, 16			; 00000010H
  01308	83 e0 0f	 and	 eax, 15			; 0000000fH
  0130b	89 4b 48	 mov	 DWORD PTR [ebx+72], ecx
  0130e	8b 4d f0	 mov	 ecx, DWORD PTR _state$1$[ebp]
  01311	8b 5d f4	 mov	 ebx, DWORD PTR _have$1$[ebp]
  01314	89 41 4c	 mov	 DWORD PTR [ecx+76], eax

; 1113 :             state->mode = DISTEXT;

  01317	c7 41 04 4b 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16203 ; 00003f4bH
$LN471@inflate:

; 1114 :                 /* fallthrough */
; 1115 :         case DISTEXT:
; 1116 :             if (state->extra) {

  0131e	8b 41 4c	 mov	 eax, DWORD PTR [ecx+76]
  01321	89 45 cc	 mov	 DWORD PTR $T11[ebp], eax
  01324	85 c0		 test	 eax, eax
  01326	74 57		 je	 SHORT $LN727@inflate

; 1117 :                 NEEDBITS(state->extra);

  01328	3b f0		 cmp	 esi, eax
  0132a	73 28		 jae	 SHORT $LN293@inflate

; 1100 :                 }
; 1101 :                 DROPBITS(last.bits);
; 1102 :                 state->back += last.bits;

  0132c	89 45 cc	 mov	 DWORD PTR $T11[ebp], eax
  0132f	90		 npad	 1
$LL296@inflate:

; 1117 :                 NEEDBITS(state->extra);

  01330	85 db		 test	 ebx, ebx
  01332	0f 84 a2 f2 ff
	ff		 je	 $LN905@inflate
  01338	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0133b	8b ce		 mov	 ecx, esi
  0133d	d3 e0		 shl	 eax, cl
  0133f	4b		 dec	 ebx
  01340	03 d0		 add	 edx, eax
  01342	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  01345	47		 inc	 edi
  01346	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  01349	83 c6 08	 add	 esi, 8
  0134c	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  0134f	3b 75 cc	 cmp	 esi, DWORD PTR $T11[ebp]
  01352	72 dc		 jb	 SHORT $LL296@inflate
$LN293@inflate:

; 1118 :                 state->offset += BITS(state->extra);

  01354	8b 4d cc	 mov	 ecx, DWORD PTR $T11[ebp]
  01357	b8 01 00 00 00	 mov	 eax, 1
  0135c	d3 e0		 shl	 eax, cl
  0135e	8b 4d f0	 mov	 ecx, DWORD PTR _state$1$[ebp]
  01361	48		 dec	 eax
  01362	23 c2		 and	 eax, edx
  01364	01 41 48	 add	 DWORD PTR [ecx+72], eax

; 1119 :                 DROPBITS(state->extra);

  01367	8b 45 cc	 mov	 eax, DWORD PTR $T11[ebp]
  0136a	8b c8		 mov	 ecx, eax
  0136c	d3 ea		 shr	 edx, cl
  0136e	2b f0		 sub	 esi, eax

; 1120 :                 state->back += state->extra;

  01370	8b 4d f0	 mov	 ecx, DWORD PTR _state$1$[ebp]
  01373	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  01376	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  01379	01 81 c8 1b 00
	00		 add	 DWORD PTR [ecx+7112], eax
$LN727@inflate:

; 1121 :             }
; 1122 : #ifdef INFLATE_STRICT
; 1123 :             if (state->offset > state->dmax) {
; 1124 :                 strm->msg = (char *)"invalid distance too far back";
; 1125 :                 state->mode = BAD;
; 1126 :                 break;
; 1127 :             }
; 1128 : #endif
; 1129 :             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
; 1130 :             state->mode = MATCH;

  0137f	c7 41 04 4c 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16204 ; 00003f4cH
$LN474@inflate:

; 1131 :                 /* fallthrough */
; 1132 :         case MATCH:
; 1133 :             if (left == 0) goto inf_leave;

  01386	83 7d e4 00	 cmp	 DWORD PTR _left$1$[ebp], 0
  0138a	0f 84 4a f2 ff
	ff		 je	 $LN905@inflate

; 1134 :             copy = out - left;

  01390	8b 45 d8	 mov	 eax, DWORD PTR _out$1$[ebp]
  01393	2b 45 e4	 sub	 eax, DWORD PTR _left$1$[ebp]
  01396	89 45 c8	 mov	 DWORD PTR _copy$7$[ebp], eax

; 1135 :             if (state->offset > copy) {         /* copy from window */

  01399	8b 41 48	 mov	 eax, DWORD PTR [ecx+72]
  0139c	89 45 d4	 mov	 DWORD PTR _copy$8$[ebp], eax
  0139f	3b 45 c8	 cmp	 eax, DWORD PTR _copy$7$[ebp]
  013a2	76 4d		 jbe	 SHORT $LN476@inflate

; 1136 :                 copy = state->offset - copy;

  013a4	2b 45 c8	 sub	 eax, DWORD PTR _copy$7$[ebp]
  013a7	89 45 d4	 mov	 DWORD PTR _copy$8$[ebp], eax

; 1137 :                 if (copy > state->whave) {

  013aa	3b 41 30	 cmp	 eax, DWORD PTR [ecx+48]
  013ad	76 18		 jbe	 SHORT $LN479@inflate

; 1138 :                     if (state->sane) {

  013af	83 b9 c4 1b 00
	00 00		 cmp	 DWORD PTR [ecx+7108], 0
  013b6	74 0f		 je	 SHORT $LN479@inflate

; 1139 :                         strm->msg = (char *)"invalid distance too far back";

  013b8	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  013bb	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back@

; 1140 :                         state->mode = BAD;
; 1141 :                         break;

  013c2	e9 c8 01 00 00	 jmp	 $LN1111@inflate
$LN479@inflate:

; 1142 :                     }
; 1143 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1144 :                     Trace((stderr, "inflate.c too far\n"));
; 1145 :                     copy -= state->whave;
; 1146 :                     if (copy > state->length) copy = state->length;
; 1147 :                     if (copy > left) copy = left;
; 1148 :                     left -= copy;
; 1149 :                     state->length -= copy;
; 1150 :                     do {
; 1151 :                         *put++ = 0;
; 1152 :                     } while (--copy);
; 1153 :                     if (state->length == 0) state->mode = LEN;
; 1154 :                     break;
; 1155 : #endif
; 1156 :                 }
; 1157 :                 if (copy > state->wnext) {

  013c7	8b 41 34	 mov	 eax, DWORD PTR [ecx+52]
  013ca	8b 79 38	 mov	 edi, DWORD PTR [ecx+56]
  013cd	39 45 d4	 cmp	 DWORD PTR _copy$8$[ebp], eax
  013d0	76 06		 jbe	 SHORT $LN480@inflate

; 1158 :                     copy -= state->wnext;

  013d2	29 45 d4	 sub	 DWORD PTR _copy$8$[ebp], eax

; 1159 :                     from = state->window + (state->wsize - copy);

  013d5	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
$LN480@inflate:

; 1160 :                 }
; 1161 :                 else
; 1162 :                     from = state->window + (state->wnext - copy);
; 1163 :                 if (copy > state->length) copy = state->length;

  013d8	2b 45 d4	 sub	 eax, DWORD PTR _copy$8$[ebp]
  013db	03 c7		 add	 eax, edi
  013dd	89 45 cc	 mov	 DWORD PTR _from$1$[ebp], eax
  013e0	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]

; 1164 :             }

  013e3	8b f8		 mov	 edi, eax
  013e5	39 7d d4	 cmp	 DWORD PTR _copy$8$[ebp], edi
  013e8	89 45 c8	 mov	 DWORD PTR $T3[ebp], eax
  013eb	0f 46 45 d4	 cmovbe	 eax, DWORD PTR _copy$8$[ebp]
  013ef	eb 0f		 jmp	 SHORT $LN1115@inflate
$LN476@inflate:

; 1165 :             else {                              /* copy from output */
; 1166 :                 from = put - state->offset;

  013f1	8b 45 dc	 mov	 eax, DWORD PTR _put$1$[ebp]
  013f4	2b 45 d4	 sub	 eax, DWORD PTR _copy$8$[ebp]
  013f7	89 45 cc	 mov	 DWORD PTR _from$1$[ebp], eax

; 1167 :                 copy = state->length;

  013fa	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]
  013fd	89 45 c8	 mov	 DWORD PTR $T3[ebp], eax
$LN1115@inflate:

; 1168 :             }
; 1169 :             if (copy > left) copy = left;
; 1170 :             left -= copy;
; 1171 :             state->length -= copy;

  01400	8b 5d cc	 mov	 ebx, DWORD PTR _from$1$[ebp]
  01403	8b f8		 mov	 edi, eax
  01405	89 45 d4	 mov	 DWORD PTR _copy$10$[ebp], eax
  01408	8b 45 e4	 mov	 eax, DWORD PTR _left$1$[ebp]
  0140b	3b f8		 cmp	 edi, eax
  0140d	0f 47 f8	 cmova	 edi, eax
  01410	2b c7		 sub	 eax, edi
  01412	89 45 e4	 mov	 DWORD PTR _left$1$[ebp], eax
  01415	8b 45 c8	 mov	 eax, DWORD PTR $T3[ebp]
  01418	2b c7		 sub	 eax, edi
  0141a	89 41 44	 mov	 DWORD PTR [ecx+68], eax
  0141d	8b 4d dc	 mov	 ecx, DWORD PTR _put$1$[ebp]
  01420	2b d9		 sub	 ebx, ecx
$LL306@inflate:

; 1172 :             do {
; 1173 :                 *put++ = *from++;

  01422	8a 04 0b	 mov	 al, BYTE PTR [ebx+ecx]
  01425	88 01		 mov	 BYTE PTR [ecx], al
  01427	41		 inc	 ecx

; 1174 :             } while (--copy);

  01428	83 ef 01	 sub	 edi, 1
  0142b	75 f5		 jne	 SHORT $LL306@inflate

; 1175 :             if (state->length == 0) state->mode = LEN;

  0142d	8b 5d f4	 mov	 ebx, DWORD PTR _have$1$[ebp]
  01430	8b 7d ec	 mov	 edi, DWORD PTR _next$1$[ebp]
  01433	89 4d dc	 mov	 DWORD PTR _put$1$[ebp], ecx
  01436	8b 4d f0	 mov	 ecx, DWORD PTR _state$1$[ebp]
  01439	83 79 44 00	 cmp	 DWORD PTR [ecx+68], 0
  0143d	0f 85 53 01 00
	00		 jne	 $LN8@inflate
  01443	c7 41 04 48 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16200 ; 00003f48H

; 1176 :             break;

  0144a	e9 47 01 00 00	 jmp	 $LN8@inflate
$LN485@inflate:

; 1177 :         case LIT:
; 1178 :             if (left == 0) goto inf_leave;

  0144f	83 7d e4 00	 cmp	 DWORD PTR _left$1$[ebp], 0
  01453	0f 84 81 f1 ff
	ff		 je	 $LN905@inflate

; 1179 :             *put++ = (unsigned char)(state->length);

  01459	8b 7d dc	 mov	 edi, DWORD PTR _put$1$[ebp]
  0145c	8a 41 44	 mov	 al, BYTE PTR [ecx+68]
  0145f	ff 45 dc	 inc	 DWORD PTR _put$1$[ebp]

; 1180 :             left--;

  01462	ff 4d e4	 dec	 DWORD PTR _left$1$[ebp]
  01465	88 07		 mov	 BYTE PTR [edi], al

; 1181 :             state->mode = LEN;
; 1182 :             break;

  01467	8b 7d ec	 mov	 edi, DWORD PTR _next$1$[ebp]
  0146a	c7 41 04 48 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16200 ; 00003f48H
  01471	e9 20 01 00 00	 jmp	 $LN8@inflate
$LN487@inflate:

; 1183 :         case CHECK:
; 1184 :             if (state->wrap) {

  01476	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  0147a	0f 84 b0 00 00
	00		 je	 $LN316@inflate

; 1185 :                 NEEDBITS(32);

  01480	83 fe 20	 cmp	 esi, 32			; 00000020H
  01483	73 2a		 jae	 SHORT $LN307@inflate
$LL310@inflate:
  01485	85 db		 test	 ebx, ebx
  01487	0f 84 4d f1 ff
	ff		 je	 $LN905@inflate
  0148d	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  01490	8b ce		 mov	 ecx, esi
  01492	d3 e0		 shl	 eax, cl
  01494	83 c6 08	 add	 esi, 8
  01497	4b		 dec	 ebx
  01498	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  0149b	03 d0		 add	 edx, eax
  0149d	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  014a0	47		 inc	 edi
  014a1	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  014a4	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  014a7	83 fe 20	 cmp	 esi, 32			; 00000020H
  014aa	72 d9		 jb	 SHORT $LL310@inflate
  014ac	8b 4d f0	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN307@inflate:

; 1186 :                 out -= left;

  014af	8b 45 e4	 mov	 eax, DWORD PTR _left$1$[ebp]
  014b2	29 45 d8	 sub	 DWORD PTR _out$1$[ebp], eax

; 1187 :                 strm->total_out += out;

  014b5	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  014b8	8b 7d d8	 mov	 edi, DWORD PTR _out$1$[ebp]
  014bb	01 78 14	 add	 DWORD PTR [eax+20], edi

; 1188 :                 state->total += out;

  014be	8b c7		 mov	 eax, edi
  014c0	01 41 20	 add	 DWORD PTR [ecx+32], eax

; 1189 :                 if ((state->wrap & 4) && out)

  014c3	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  014c7	8b 7d ec	 mov	 edi, DWORD PTR _next$1$[ebp]
  014ca	74 33		 je	 SHORT $LN490@inflate
  014cc	85 c0		 test	 eax, eax
  014ce	74 2f		 je	 SHORT $LN490@inflate

; 1190 :                     strm->adler = state->check =

  014d0	8b 45 dc	 mov	 eax, DWORD PTR _put$1$[ebp]
  014d3	ff 75 d8	 push	 DWORD PTR _out$1$[ebp]
  014d6	2b 45 d8	 sub	 eax, DWORD PTR _out$1$[ebp]
  014d9	83 79 14 00	 cmp	 DWORD PTR [ecx+20], 0
  014dd	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  014e0	50		 push	 eax
  014e1	52		 push	 edx
  014e2	74 07		 je	 SHORT $LN512@inflate
  014e4	e8 00 00 00 00	 call	 _crc32@12
  014e9	eb 05		 jmp	 SHORT $LN513@inflate
$LN512@inflate:
  014eb	e8 00 00 00 00	 call	 _adler32@12
$LN513@inflate:
  014f0	8b 4d f0	 mov	 ecx, DWORD PTR _state$1$[ebp]
  014f3	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  014f6	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  014f9	89 42 30	 mov	 DWORD PTR [edx+48], eax
  014fc	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN490@inflate:

; 1191 :                         UPDATE_CHECK(state->check, put - out, out);
; 1192 :                 out = left;
; 1193 :                 if ((state->wrap & 4) && (

  014ff	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  01503	8b 45 e4	 mov	 eax, DWORD PTR _left$1$[ebp]
  01506	89 45 d8	 mov	 DWORD PTR _out$1$[ebp], eax
  01509	74 1b		 je	 SHORT $LN317@inflate
  0150b	83 79 14 00	 cmp	 DWORD PTR [ecx+20], 0
  0150f	8b c2		 mov	 eax, edx
  01511	75 02		 jne	 SHORT $LN515@inflate
  01513	0f c8		 bswap	 eax
$LN515@inflate:
  01515	3b 41 1c	 cmp	 eax, DWORD PTR [ecx+28]
  01518	74 0c		 je	 SHORT $LN317@inflate

; 1194 : #ifdef GUNZIP
; 1195 :                      state->flags ? hold :
; 1196 : #endif
; 1197 :                      ZSWAP32(hold)) != state->check) {
; 1198 :                     strm->msg = (char *)"incorrect data check";

  0151a	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0151d	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BF@MEIGEHBE@incorrect?5data?5check@

; 1199 :                     state->mode = BAD;
; 1200 :                     break;

  01524	eb 69		 jmp	 SHORT $LN1111@inflate
$LN317@inflate:

; 1201 :                 }
; 1202 :                 INITBITS();

  01526	33 d2		 xor	 edx, edx
  01528	33 f6		 xor	 esi, esi
  0152a	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  0152d	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
$LN316@inflate:

; 1203 :                 Tracev((stderr, "inflate:   check matches trailer\n"));
; 1204 :             }
; 1205 : #ifdef GUNZIP
; 1206 :             state->mode = LENGTH;

  01530	c7 41 04 4f 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16207 ; 00003f4fH
$LN492@inflate:

; 1207 :                 /* fallthrough */
; 1208 :         case LENGTH:
; 1209 :             if (state->wrap && state->flags) {

  01537	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  0153b	0f 84 a5 00 00
	00		 je	 $LN327@inflate
  01541	83 79 14 00	 cmp	 DWORD PTR [ecx+20], 0
  01545	0f 84 9b 00 00
	00		 je	 $LN327@inflate

; 1210 :                 NEEDBITS(32);

  0154b	83 fe 20	 cmp	 esi, 32			; 00000020H
  0154e	73 2a		 jae	 SHORT $LN318@inflate
$LL321@inflate:
  01550	85 db		 test	 ebx, ebx
  01552	0f 84 82 f0 ff
	ff		 je	 $LN905@inflate
  01558	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0155b	8b ce		 mov	 ecx, esi
  0155d	d3 e0		 shl	 eax, cl
  0155f	83 c6 08	 add	 esi, 8
  01562	4b		 dec	 ebx
  01563	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  01566	03 d0		 add	 edx, eax
  01568	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  0156b	47		 inc	 edi
  0156c	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  0156f	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  01572	83 fe 20	 cmp	 esi, 32			; 00000020H
  01575	72 d9		 jb	 SHORT $LL321@inflate
  01577	8b 4d f0	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN318@inflate:

; 1211 :                 if ((state->wrap & 4) && hold != (state->total & 0xffffffff)) {

  0157a	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  0157e	74 5d		 je	 SHORT $LN328@inflate
  01580	3b 51 20	 cmp	 edx, DWORD PTR [ecx+32]
  01583	74 58		 je	 SHORT $LN328@inflate

; 1212 :                     strm->msg = (char *)"incorrect length check";

  01585	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01588	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BH@FGKKJGOC@incorrect?5length?5check@
$LN1111@inflate:

; 620  :     for (;;)
; 621  :         switch (state->mode) {

  0158f	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
$LN8@inflate:
  01596	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  01599	2d 34 3f 00 00	 sub	 eax, 16180		; 00003f34H
  0159e	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  015a1	0f 86 fd ea ff
	ff		 jbe	 $LL5@inflate
$LN333@inflate:
  015a7	5f		 pop	 edi

; 1262 :         ret = Z_BUF_ERROR;
; 1263 :     return ret;
; 1264 : }

  015a8	5e		 pop	 esi
  015a9	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  015ae	5b		 pop	 ebx
  015af	8b e5		 mov	 esp, ebp
  015b1	5d		 pop	 ebp
  015b2	c2 08 00	 ret	 8
$LN587@inflate:

; 818  :                 RESTORE();

  015b5	8b 4d dc	 mov	 ecx, DWORD PTR _put$1$[ebp]
  015b8	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  015bb	8b 4d e4	 mov	 ecx, DWORD PTR _left$1$[ebp]
  015be	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  015c1	8b 4d f0	 mov	 ecx, DWORD PTR _state$1$[ebp]
  015c4	89 38		 mov	 DWORD PTR [eax], edi
  015c6	89 58 04	 mov	 DWORD PTR [eax+4], ebx

; 819  :                 return Z_NEED_DICT;

  015c9	b8 02 00 00 00	 mov	 eax, 2
  015ce	5f		 pop	 edi
  015cf	89 71 40	 mov	 DWORD PTR [ecx+64], esi

; 1262 :         ret = Z_BUF_ERROR;
; 1263 :     return ret;
; 1264 : }

  015d2	5e		 pop	 esi
  015d3	89 51 3c	 mov	 DWORD PTR [ecx+60], edx
  015d6	5b		 pop	 ebx
  015d7	8b e5		 mov	 esp, ebp
  015d9	5d		 pop	 ebp
  015da	c2 08 00	 ret	 8
$LN328@inflate:

; 1213 :                     state->mode = BAD;
; 1214 :                     break;
; 1215 :                 }
; 1216 :                 INITBITS();

  015dd	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hold$1$[ebp], 0
  015e4	33 f6		 xor	 esi, esi
$LN327@inflate:

; 1217 :                 Tracev((stderr, "inflate:   length matches trailer\n"));
; 1218 :             }
; 1219 : #endif
; 1220 :             state->mode = DONE;

  015e6	c7 41 04 50 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16208 ; 00003f50H
$LN496@inflate:

; 1221 :                 /* fallthrough */
; 1222 :         case DONE:
; 1223 :             ret = Z_STREAM_END;

  015ed	c7 45 d0 01 00
	00 00		 mov	 DWORD PTR _ret$1$[ebp], 1

; 1224 :             goto inf_leave;

  015f4	e9 e1 ef ff ff	 jmp	 $LN905@inflate
$LN497@inflate:

; 1225 :         case BAD:
; 1226 :             ret = Z_DATA_ERROR;

  015f9	c7 45 d0 fd ff
	ff ff		 mov	 DWORD PTR _ret$1$[ebp], -3 ; fffffffdH
  01600	e9 d5 ef ff ff	 jmp	 $LN905@inflate
$LN881@inflate:

; 1018 :             }
; 1019 :             Tracev((stderr, "inflate:       codes ok\n"));
; 1020 :             state->mode = LEN_;
; 1021 :             if (flush == Z_TREES) goto inf_leave;

  01605	8b 45 f4	 mov	 eax, DWORD PTR _have$1$[ebp]
  01608	e9 d3 ef ff ff	 jmp	 $inf_leave$1117
$LN504@inflate:

; 1248 :             return Z_MEM_ERROR;
; 1249 :         }
; 1250 :     in -= strm->avail_in;

  0160d	8b 45 c0	 mov	 eax, DWORD PTR _in$1$[ebp]
  01610	2b 47 04	 sub	 eax, DWORD PTR [edi+4]

; 1251 :     out -= strm->avail_out;

  01613	2b 77 10	 sub	 esi, DWORD PTR [edi+16]

; 1252 :     strm->total_in += in;

  01616	01 47 08	 add	 DWORD PTR [edi+8], eax

; 1253 :     strm->total_out += out;

  01619	01 77 14	 add	 DWORD PTR [edi+20], esi

; 1254 :     state->total += out;

  0161c	01 73 20	 add	 DWORD PTR [ebx+32], esi

; 1255 :     if ((state->wrap & 4) && out)

  0161f	f6 43 0c 04	 test	 BYTE PTR [ebx+12], 4
  01623	89 45 c0	 mov	 DWORD PTR _in$1$[ebp], eax
  01626	89 75 d8	 mov	 DWORD PTR _out$1$[ebp], esi
  01629	74 27		 je	 SHORT $LN505@inflate
  0162b	85 f6		 test	 esi, esi
  0162d	74 23		 je	 SHORT $LN505@inflate

; 1256 :         strm->adler = state->check =

  0162f	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  01632	8b 4b 1c	 mov	 ecx, DWORD PTR [ebx+28]
  01635	2b c6		 sub	 eax, esi
  01637	83 7b 14 00	 cmp	 DWORD PTR [ebx+20], 0
  0163b	56		 push	 esi
  0163c	50		 push	 eax
  0163d	51		 push	 ecx
  0163e	74 07		 je	 SHORT $LN516@inflate
  01640	e8 00 00 00 00	 call	 _crc32@12
  01645	eb 05		 jmp	 SHORT $LN517@inflate
$LN516@inflate:
  01647	e8 00 00 00 00	 call	 _adler32@12
$LN517@inflate:
  0164c	89 43 1c	 mov	 DWORD PTR [ebx+28], eax
  0164f	89 47 30	 mov	 DWORD PTR [edi+48], eax
$LN505@inflate:

; 1257 :             UPDATE_CHECK(state->check, strm->next_out - out, out);
; 1258 :     strm->data_type = (int)state->bits + (state->last ? 64 : 0) +

  01652	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  01655	81 fa 47 3f 00
	00		 cmp	 edx, 16199		; 00003f47H
  0165b	74 0c		 je	 SHORT $LN518@inflate
  0165d	81 fa 42 3f 00
	00		 cmp	 edx, 16194		; 00003f42H
  01663	74 04		 je	 SHORT $LN518@inflate
  01665	33 f6		 xor	 esi, esi
  01667	eb 05		 jmp	 SHORT $LN519@inflate
$LN518@inflate:
  01669	be 00 01 00 00	 mov	 esi, 256		; 00000100H
$LN519@inflate:
  0166e	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  01671	f7 d9		 neg	 ecx
  01673	c7 45 08 80 00
	00 00		 mov	 DWORD PTR tv4931[ebp], 128 ; 00000080H
  0167a	1b c9		 sbb	 ecx, ecx
  0167c	33 c0		 xor	 eax, eax
  0167e	83 e1 40	 and	 ecx, 64			; 00000040H
  01681	81 fa 3f 3f 00
	00		 cmp	 edx, 16191		; 00003f3fH
  01687	0f 44 45 08	 cmove	 eax, DWORD PTR tv4931[ebp]
  0168b	03 c8		 add	 ecx, eax
  0168d	03 4b 40	 add	 ecx, DWORD PTR [ebx+64]
  01690	03 ce		 add	 ecx, esi

; 1259 :                       (state->mode == TYPE ? 128 : 0) +
; 1260 :                       (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);
; 1261 :     if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)

  01692	83 7d c0 00	 cmp	 DWORD PTR _in$1$[ebp], 0
  01696	89 4f 2c	 mov	 DWORD PTR [edi+44], ecx
  01699	75 06		 jne	 SHORT $LN508@inflate
  0169b	83 7d d8 00	 cmp	 DWORD PTR _out$1$[ebp], 0
  0169f	74 06		 je	 SHORT $LN507@inflate
$LN508@inflate:
  016a1	83 7d 0c 04	 cmp	 DWORD PTR _flush$[ebp], 4
  016a5	75 16		 jne	 SHORT $LN913@inflate
$LN507@inflate:
  016a7	8b 45 d0	 mov	 eax, DWORD PTR _ret$1$[ebp]
  016aa	b9 fb ff ff ff	 mov	 ecx, -5			; fffffffbH
  016af	5f		 pop	 edi
  016b0	85 c0		 test	 eax, eax

; 1262 :         ret = Z_BUF_ERROR;
; 1263 :     return ret;
; 1264 : }

  016b2	5e		 pop	 esi
  016b3	0f 44 c1	 cmove	 eax, ecx
  016b6	5b		 pop	 ebx
  016b7	8b e5		 mov	 esp, ebp
  016b9	5d		 pop	 ebp
  016ba	c2 08 00	 ret	 8
$LN913@inflate:

; 1259 :                       (state->mode == TYPE ? 128 : 0) +
; 1260 :                       (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);
; 1261 :     if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)

  016bd	8b 45 d0	 mov	 eax, DWORD PTR _ret$1$[ebp]
  016c0	5f		 pop	 edi

; 1262 :         ret = Z_BUF_ERROR;
; 1263 :     return ret;
; 1264 : }

  016c1	5e		 pop	 esi
  016c2	5b		 pop	 ebx
  016c3	8b e5		 mov	 esp, ebp
  016c5	5d		 pop	 ebp
  016c6	c2 08 00	 ret	 8
  016c9	0f 1f 00	 npad	 3
$LN787@inflate:
  016cc	00 00 00 00	 DD	 $LN335@inflate
  016d0	00 00 00 00	 DD	 $LN32@inflate
  016d4	00 00 00 00	 DD	 $LN46@inflate
  016d8	00 00 00 00	 DD	 $LN60@inflate
  016dc	00 00 00 00	 DD	 $LN361@inflate
  016e0	00 00 00 00	 DD	 $LN368@inflate
  016e4	00 00 00 00	 DD	 $LN375@inflate
  016e8	00 00 00 00	 DD	 $LN384@inflate
  016ec	00 00 00 00	 DD	 $LN393@inflate
  016f0	00 00 00 00	 DD	 $LN105@inflate
  016f4	00 00 00 00	 DD	 $LN911@inflate
  016f8	00 00 00 00	 DD	 $LN402@inflate
  016fc	00 00 00 00	 DD	 $LN403@inflate
  01700	00 00 00 00	 DD	 $LN141@inflate
  01704	00 00 00 00	 DD	 $LN416@inflate
  01708	00 00 00 00	 DD	 $LN418@inflate
  0170c	00 00 00 00	 DD	 $LN155@inflate
  01710	00 00 00 00	 DD	 $LN533@inflate
  01714	00 00 00 00	 DD	 $LN536@inflate
  01718	00 00 00 00	 DD	 $LN448@inflate
  0171c	00 00 00 00	 DD	 $LN450@inflate
  01720	00 00 00 00	 DD	 $LN461@inflate
  01724	00 00 00 00	 DD	 $LN464@inflate
  01728	00 00 00 00	 DD	 $LN471@inflate
  0172c	00 00 00 00	 DD	 $LN474@inflate
  01730	00 00 00 00	 DD	 $LN485@inflate
  01734	00 00 00 00	 DD	 $LN487@inflate
  01738	00 00 00 00	 DD	 $LN492@inflate
  0173c	00 00 00 00	 DD	 $LN496@inflate
  01740	00 00 00 00	 DD	 $LN497@inflate
  01744	00 00 00 00	 DD	 $LN498@inflate
  01748	00 00 00 00	 DD	 $LN333@inflate
$LN788@inflate:
  0174c	00 00 00 00	 DD	 $LN408@inflate
  01750	00 00 00 00	 DD	 $LN409@inflate
  01754	00 00 00 00	 DD	 $LN411@inflate
  01758	00 00 00 00	 DD	 $LN412@inflate
_inflate@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\Pichau\Documents\Boldergarte\Softwares\LIBRARIES\downloads\zlib\zlib-develop\zlib-develop\inflate.c
;	COMDAT _inflateEnd@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateEnd@4 PROC					; COMDAT

; 1266 : int ZEXPORT inflateEnd(z_streamp strm) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 08	 mov	 esi, DWORD PTR _strm$[ebp]

; 1267 :     struct inflate_state FAR *state;
; 1268 :     if (inflateStateCheck(strm))

  00007	8b ce		 mov	 ecx, esi
  00009	e8 00 00 00 00	 call	 _inflateStateCheck
  0000e	85 c0		 test	 eax, eax
  00010	74 0a		 je	 SHORT $LN2@inflateEnd

; 1269 :         return Z_STREAM_ERROR;

  00012	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00017	5e		 pop	 esi

; 1276 : }

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
$LN2@inflateEnd:

; 1270 :     state = (struct inflate_state FAR *)strm->state;
; 1271 :     if (state->window != Z_NULL) ZFREE(strm, state->window);

  0001c	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0001f	53		 push	 ebx
  00020	57		 push	 edi
  00021	8b 40 38	 mov	 eax, DWORD PTR [eax+56]
  00024	85 c0		 test	 eax, eax
  00026	74 0c		 je	 SHORT $LN5@inflateEnd
  00028	50		 push	 eax
  00029	ff 76 28	 push	 DWORD PTR [esi+40]
  0002c	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  0002f	ff d0		 call	 eax
  00031	83 c4 08	 add	 esp, 8
$LN5@inflateEnd:

; 1272 :     ZFREE(strm, strm->state);

  00034	ff 76 1c	 push	 DWORD PTR [esi+28]
  00037	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  0003a	ff 76 28	 push	 DWORD PTR [esi+40]
  0003d	ff d0		 call	 eax
  0003f	83 c4 08	 add	 esp, 8

; 1273 :     strm->state = Z_NULL;

  00042	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0

; 1274 :     Tracev((stderr, "inflate: end\n"));
; 1275 :     return Z_OK;

  00049	33 c0		 xor	 eax, eax
  0004b	5f		 pop	 edi
  0004c	5b		 pop	 ebx
  0004d	5e		 pop	 esi

; 1276 : }

  0004e	5d		 pop	 ebp
  0004f	c2 04 00	 ret	 4
_inflateEnd@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\Pichau\Documents\Boldergarte\Softwares\LIBRARIES\downloads\zlib\zlib-develop\zlib-develop\inflate.c
;	COMDAT _inflateStateCheck
_TEXT	SEGMENT
_inflateStateCheck PROC					; COMDAT
; _strm$ = ecx

; 95   :     struct inflate_state FAR *state;
; 96   :     if (strm == Z_NULL ||
; 97   :         strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0)

  00000	85 c9		 test	 ecx, ecx
  00002	74 27		 je	 SHORT $LN3@inflateSta
  00004	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  00008	74 21		 je	 SHORT $LN3@inflateSta
  0000a	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  0000e	74 1b		 je	 SHORT $LN3@inflateSta

; 99   :     state = (struct inflate_state FAR *)strm->state;

  00010	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]

; 100  :     if (state == Z_NULL || state->strm != strm ||
; 101  :         state->mode < HEAD || state->mode > SYNC)

  00013	85 c0		 test	 eax, eax
  00015	74 14		 je	 SHORT $LN3@inflateSta
  00017	39 08		 cmp	 DWORD PTR [eax], ecx
  00019	75 10		 jne	 SHORT $LN3@inflateSta
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	2d 34 3f 00 00	 sub	 eax, 16180		; 00003f34H
  00023	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00026	77 03		 ja	 SHORT $LN3@inflateSta

; 102  :         return 1;
; 103  :     return 0;

  00028	33 c0		 xor	 eax, eax

; 104  : }

  0002a	c3		 ret	 0
$LN3@inflateSta:

; 98   :         return 1;

  0002b	b8 01 00 00 00	 mov	 eax, 1

; 104  : }

  00030	c3		 ret	 0
_inflateStateCheck ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\Pichau\Documents\Boldergarte\Softwares\LIBRARIES\downloads\zlib\zlib-develop\zlib-develop\inflate.c
;	COMDAT _inflateResetKeep@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateResetKeep@4 PROC				; COMDAT

; 106  : int ZEXPORT inflateResetKeep(z_streamp strm) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 107  :     struct inflate_state FAR *state;
; 108  : 
; 109  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00006	8b ca		 mov	 ecx, edx
  00008	e8 00 00 00 00	 call	 _inflateStateCheck
  0000d	85 c0		 test	 eax, eax
  0000f	74 09		 je	 SHORT $LN2@inflateRes
  00011	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 128  : }

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
$LN2@inflateRes:

; 110  :     state = (struct inflate_state FAR *)strm->state;

  0001a	8b 4a 1c	 mov	 ecx, DWORD PTR [edx+28]

; 111  :     strm->total_in = strm->total_out = state->total = 0;

  0001d	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0
  00024	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], 0
  0002b	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 112  :     strm->msg = Z_NULL;

  00032	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], 0

; 113  :     if (state->wrap)        /* to support ill-conceived Java test suite */

  00039	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0003c	85 c0		 test	 eax, eax
  0003e	74 06		 je	 SHORT $LN3@inflateRes

; 114  :         strm->adler = state->wrap & 1;

  00040	83 e0 01	 and	 eax, 1
  00043	89 42 30	 mov	 DWORD PTR [edx+48], eax
$LN3@inflateRes:

; 115  :     state->mode = HEAD;
; 116  :     state->last = 0;
; 117  :     state->havedict = 0;
; 118  :     state->flags = -1;
; 119  :     state->dmax = 32768U;
; 120  :     state->head = Z_NULL;
; 121  :     state->hold = 0;
; 122  :     state->bits = 0;
; 123  :     state->lencode = state->distcode = state->next = state->codes;

  00046	8d 81 34 05 00
	00		 lea	 eax, DWORD PTR [ecx+1332]
  0004c	c7 41 04 34 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16180 ; 00003f34H
  00053	89 41 70	 mov	 DWORD PTR [ecx+112], eax
  00056	89 41 54	 mov	 DWORD PTR [ecx+84], eax
  00059	89 41 50	 mov	 DWORD PTR [ecx+80], eax

; 124  :     state->sane = 1;
; 125  :     state->back = -1;
; 126  :     Tracev((stderr, "inflate: reset\n"));
; 127  :     return Z_OK;

  0005c	33 c0		 xor	 eax, eax
  0005e	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00065	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  0006c	c7 41 14 ff ff
	ff ff		 mov	 DWORD PTR [ecx+20], -1
  00073	c7 41 18 00 80
	00 00		 mov	 DWORD PTR [ecx+24], 32768 ; 00008000H
  0007a	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0
  00081	c7 41 3c 00 00
	00 00		 mov	 DWORD PTR [ecx+60], 0
  00088	c7 41 40 00 00
	00 00		 mov	 DWORD PTR [ecx+64], 0
  0008f	c7 81 c4 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [ecx+7108], 1
  00099	c7 81 c8 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+7112], -1

; 128  : }

  000a3	5d		 pop	 ebp
  000a4	c2 04 00	 ret	 4
_inflateResetKeep@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\Pichau\Documents\Boldergarte\Softwares\LIBRARIES\downloads\zlib\zlib-develop\zlib-develop\inflate.c
;	COMDAT _inflateReset2@8
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_windowBits$ = 12					; size = 4
_inflateReset2@8 PROC					; COMDAT

; 141  : int ZEXPORT inflateReset2(z_streamp strm, int windowBits) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 142  :     int wrap;
; 143  :     struct inflate_state FAR *state;
; 144  : 
; 145  :     /* get the state */
; 146  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b 75 0c	 mov	 esi, DWORD PTR _windowBits$[ebp]
  0000b	57		 push	 edi
  0000c	e8 00 00 00 00	 call	 _inflateStateCheck
  00011	85 c0		 test	 eax, eax
  00013	75 65		 jne	 SHORT $LN8@inflateRes

; 147  :     state = (struct inflate_state FAR *)strm->state;

  00015	8b 59 1c	 mov	 ebx, DWORD PTR [ecx+28]

; 148  : 
; 149  :     /* extract wrap request from windowBits parameter */
; 150  :     if (windowBits < 0) {

  00018	85 f6		 test	 esi, esi
  0001a	79 0b		 jns	 SHORT $LN3@inflateRes

; 151  :         if (windowBits < -15)

  0001c	83 fe f1	 cmp	 esi, -15		; fffffff1H
  0001f	7c 59		 jl	 SHORT $LN8@inflateRes

; 152  :             return Z_STREAM_ERROR;
; 153  :         wrap = 0;

  00021	33 ff		 xor	 edi, edi

; 154  :         windowBits = -windowBits;

  00023	f7 de		 neg	 esi

; 155  :     }

  00025	eb 10		 jmp	 SHORT $LN6@inflateRes
$LN3@inflateRes:

; 156  :     else {
; 157  :         wrap = (windowBits >> 4) + 5;

  00027	8b fe		 mov	 edi, esi
  00029	c1 ef 04	 shr	 edi, 4
  0002c	83 c7 05	 add	 edi, 5

; 158  : #ifdef GUNZIP
; 159  :         if (windowBits < 48)

  0002f	83 fe 30	 cmp	 esi, 48			; 00000030H
  00032	7d 03		 jge	 SHORT $LN6@inflateRes

; 160  :             windowBits &= 15;

  00034	83 e6 0f	 and	 esi, 15			; 0000000fH
$LN6@inflateRes:

; 161  : #endif
; 162  :     }
; 163  : 
; 164  :     /* set number of window bits, free window if different */
; 165  :     if (windowBits && (windowBits < 8 || windowBits > 15))

  00037	85 f6		 test	 esi, esi
  00039	74 0a		 je	 SHORT $LN7@inflateRes
  0003b	83 fe 08	 cmp	 esi, 8
  0003e	7c 3a		 jl	 SHORT $LN8@inflateRes
  00040	83 fe 0f	 cmp	 esi, 15			; 0000000fH
  00043	7f 35		 jg	 SHORT $LN8@inflateRes
$LN7@inflateRes:

; 166  :         return Z_STREAM_ERROR;
; 167  :     if (state->window != Z_NULL && state->wbits != (unsigned)windowBits) {

  00045	8b 43 38	 mov	 eax, DWORD PTR [ebx+56]
  00048	85 c0		 test	 eax, eax
  0004a	74 1b		 je	 SHORT $LN9@inflateRes
  0004c	39 73 28	 cmp	 DWORD PTR [ebx+40], esi
  0004f	74 16		 je	 SHORT $LN9@inflateRes

; 168  :         ZFREE(strm, state->window);

  00051	50		 push	 eax
  00052	ff 71 28	 push	 DWORD PTR [ecx+40]
  00055	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  00058	ff d0		 call	 eax
  0005a	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0005d	83 c4 08	 add	 esp, 8

; 169  :         state->window = Z_NULL;

  00060	c7 43 38 00 00
	00 00		 mov	 DWORD PTR [ebx+56], 0
$LN9@inflateRes:

; 170  :     }
; 171  : 
; 172  :     /* update state and reset the rest of it */
; 173  :     state->wrap = wrap;
; 174  :     state->wbits = (unsigned)windowBits;
; 175  :     return inflateReset(strm);

  00067	51		 push	 ecx
  00068	89 7b 0c	 mov	 DWORD PTR [ebx+12], edi
  0006b	89 73 28	 mov	 DWORD PTR [ebx+40], esi
  0006e	e8 00 00 00 00	 call	 _inflateReset@4
  00073	5f		 pop	 edi

; 176  : }

  00074	5e		 pop	 esi
  00075	5b		 pop	 ebx
  00076	5d		 pop	 ebp
  00077	c2 08 00	 ret	 8
$LN8@inflateRes:
  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
  0007c	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00081	5b		 pop	 ebx
  00082	5d		 pop	 ebp
  00083	c2 08 00	 ret	 8
_inflateReset2@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\Pichau\Documents\Boldergarte\Softwares\LIBRARIES\downloads\zlib\zlib-develop\zlib-develop\inflate.c
;	COMDAT _inflateInit_@12
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_version$ = 12						; size = 4
_stream_size$ = 16					; size = 4
_inflateInit_@12 PROC					; COMDAT

; 219  :                          int stream_size) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 220  :     return inflateInit2_(strm, DEF_WBITS, version, stream_size);

  00003	ff 75 10	 push	 DWORD PTR _stream_size$[ebp]
  00006	ff 75 0c	 push	 DWORD PTR _version$[ebp]
  00009	6a 0f		 push	 15			; 0000000fH
  0000b	ff 75 08	 push	 DWORD PTR _strm$[ebp]
  0000e	e8 00 00 00 00	 call	 _inflateInit2_@16

; 221  : }

  00013	5d		 pop	 ebp
  00014	c2 0c 00	 ret	 12			; 0000000cH
_inflateInit_@12 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\Pichau\Documents\Boldergarte\Softwares\LIBRARIES\downloads\zlib\zlib-develop\zlib-develop\inflate.c
;	COMDAT _inflatePrime@12
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_bits$ = 12						; size = 4
_value$ = 16						; size = 4
_inflatePrime@12 PROC					; COMDAT

; 223  : int ZEXPORT inflatePrime(z_streamp strm, int bits, int value) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 224  :     struct inflate_state FAR *state;
; 225  : 
; 226  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00006	8b ca		 mov	 ecx, edx
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	e8 00 00 00 00	 call	 _inflateStateCheck
  0000f	85 c0		 test	 eax, eax
  00011	75 47		 jne	 SHORT $LN6@inflatePri

; 227  :     if (bits == 0)

  00013	8b 4d 0c	 mov	 ecx, DWORD PTR _bits$[ebp]
  00016	85 c9		 test	 ecx, ecx
  00018	74 0b		 je	 SHORT $LN14@inflatePri

; 228  :         return Z_OK;
; 229  :     state = (struct inflate_state FAR *)strm->state;

  0001a	8b 52 1c	 mov	 edx, DWORD PTR [edx+28]

; 230  :     if (bits < 0) {

  0001d	79 0e		 jns	 SHORT $LN4@inflatePri

; 231  :         state->hold = 0;

  0001f	89 42 3c	 mov	 DWORD PTR [edx+60], eax

; 232  :         state->bits = 0;

  00022	89 42 40	 mov	 DWORD PTR [edx+64], eax
$LN14@inflatePri:

; 240  : }

  00025	5f		 pop	 edi
  00026	33 c0		 xor	 eax, eax
  00028	5e		 pop	 esi
  00029	5d		 pop	 ebp
  0002a	c2 0c 00	 ret	 12			; 0000000cH
$LN4@inflatePri:

; 233  :         return Z_OK;
; 234  :     }
; 235  :     if (bits > 16 || state->bits + (uInt)bits > 32) return Z_STREAM_ERROR;

  0002d	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00030	7f 28		 jg	 SHORT $LN6@inflatePri
  00032	8b 72 40	 mov	 esi, DWORD PTR [edx+64]
  00035	8d 3c 0e	 lea	 edi, DWORD PTR [esi+ecx]
  00038	83 ff 20	 cmp	 edi, 32			; 00000020H
  0003b	77 1d		 ja	 SHORT $LN6@inflatePri

; 236  :     value &= (1L << bits) - 1;

  0003d	b8 01 00 00 00	 mov	 eax, 1

; 237  :     state->hold += (unsigned)value << state->bits;
; 238  :     state->bits += (uInt)bits;

  00042	89 7a 40	 mov	 DWORD PTR [edx+64], edi
  00045	d3 e0		 shl	 eax, cl
  00047	8b ce		 mov	 ecx, esi
  00049	48		 dec	 eax
  0004a	23 45 10	 and	 eax, DWORD PTR _value$[ebp]
  0004d	d3 e0		 shl	 eax, cl
  0004f	01 42 3c	 add	 DWORD PTR [edx+60], eax

; 239  :     return Z_OK;

  00052	33 c0		 xor	 eax, eax
  00054	5f		 pop	 edi

; 240  : }

  00055	5e		 pop	 esi
  00056	5d		 pop	 ebp
  00057	c2 0c 00	 ret	 12			; 0000000cH
$LN6@inflatePri:
  0005a	5f		 pop	 edi

; 233  :         return Z_OK;
; 234  :     }
; 235  :     if (bits > 16 || state->bits + (uInt)bits > 32) return Z_STREAM_ERROR;

  0005b	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 240  : }

  00060	5e		 pop	 esi
  00061	5d		 pop	 ebp
  00062	c2 0c 00	 ret	 12			; 0000000cH
_inflatePrime@12 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\Pichau\Documents\Boldergarte\Softwares\LIBRARIES\downloads\zlib\zlib-develop\zlib-develop\inflate.c
;	COMDAT _fixedtables
_TEXT	SEGMENT
_fixedtables PROC					; COMDAT
; _state$ = ecx

; 253  : #ifdef BUILDFIXED
; 254  :     static int virgin = 1;
; 255  :     static code *lenfix, *distfix;
; 256  :     static code fixed[544];
; 257  : 
; 258  :     /* build fixed huffman tables if first call (may not be thread safe) */
; 259  :     if (virgin) {
; 260  :         unsigned sym, bits;
; 261  :         static code *next;
; 262  : 
; 263  :         /* literal/length table */
; 264  :         sym = 0;
; 265  :         while (sym < 144) state->lens[sym++] = 8;
; 266  :         while (sym < 256) state->lens[sym++] = 9;
; 267  :         while (sym < 280) state->lens[sym++] = 7;
; 268  :         while (sym < 288) state->lens[sym++] = 8;
; 269  :         next = fixed;
; 270  :         lenfix = next;
; 271  :         bits = 9;
; 272  :         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
; 273  : 
; 274  :         /* distance table */
; 275  :         sym = 0;
; 276  :         while (sym < 32) state->lens[sym++] = 5;
; 277  :         distfix = next;
; 278  :         bits = 5;
; 279  :         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
; 280  : 
; 281  :         /* do this just once */
; 282  :         virgin = 0;
; 283  :     }
; 284  : #else /* !BUILDFIXED */
; 285  : #   include "inffixed.h"
; 286  : #endif /* BUILDFIXED */
; 287  :     state->lencode = lenfix;

  00000	c7 41 50 00 00
	00 00		 mov	 DWORD PTR [ecx+80], OFFSET ?lenfix@?1??fixedtables@@9@9

; 288  :     state->lenbits = 9;

  00007	c7 41 58 09 00
	00 00		 mov	 DWORD PTR [ecx+88], 9

; 289  :     state->distcode = distfix;

  0000e	c7 41 54 00 00
	00 00		 mov	 DWORD PTR [ecx+84], OFFSET ?distfix@?1??fixedtables@@9@9

; 290  :     state->distbits = 5;

  00015	c7 41 5c 05 00
	00 00		 mov	 DWORD PTR [ecx+92], 5

; 291  : }

  0001c	c3		 ret	 0
_fixedtables ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\Pichau\Documents\Boldergarte\Softwares\LIBRARIES\downloads\zlib\zlib-develop\zlib-develop\inflate.c
;	COMDAT _updatewindow
_TEXT	SEGMENT
_end$1$ = -4						; size = 4
_copy$ = 8						; size = 4
_updatewindow PROC					; COMDAT
; _strm$ = ecx
; _end$ = edx

; 368  : local int updatewindow(z_streamp strm, const Bytef *end, unsigned copy) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx
  00009	8b c2		 mov	 eax, edx
  0000b	89 45 fc	 mov	 DWORD PTR _end$1$[ebp], eax

; 369  :     struct inflate_state FAR *state;
; 370  :     unsigned dist;
; 371  : 
; 372  :     state = (struct inflate_state FAR *)strm->state;

  0000e	8b 77 1c	 mov	 esi, DWORD PTR [edi+28]

; 373  : 
; 374  :     /* if it hasn't been done already, allocate space for the window */
; 375  :     if (state->window == Z_NULL) {

  00011	8b 56 38	 mov	 edx, DWORD PTR [esi+56]
  00014	85 d2		 test	 edx, edx
  00016	75 2e		 jne	 SHORT $LN13@updatewind

; 376  :         state->window = (unsigned char FAR *)

  00018	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  0001b	b8 01 00 00 00	 mov	 eax, 1
  00020	d3 e0		 shl	 eax, cl
  00022	8b 4f 20	 mov	 ecx, DWORD PTR [edi+32]
  00025	6a 01		 push	 1
  00027	50		 push	 eax
  00028	ff 77 28	 push	 DWORD PTR [edi+40]
  0002b	ff d1		 call	 ecx
  0002d	8b d0		 mov	 edx, eax
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00032	89 56 38	 mov	 DWORD PTR [esi+56], edx

; 377  :                         ZALLOC(strm, 1U << state->wbits,
; 378  :                                sizeof(unsigned char));
; 379  :         if (state->window == Z_NULL) return 1;

  00035	85 d2		 test	 edx, edx
  00037	75 0a		 jne	 SHORT $LN17@updatewind

; 412  : }

  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  0003e	5b		 pop	 ebx
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
$LN17@updatewind:

; 377  :                         ZALLOC(strm, 1U << state->wbits,
; 378  :                                sizeof(unsigned char));
; 379  :         if (state->window == Z_NULL) return 1;

  00043	8b 45 fc	 mov	 eax, DWORD PTR _end$1$[ebp]
$LN13@updatewind:

; 380  :     }
; 381  : 
; 382  :     /* if window not in use yet, initialize */
; 383  :     if (state->wsize == 0) {

  00046	8b 7e 2c	 mov	 edi, DWORD PTR [esi+44]
  00049	85 ff		 test	 edi, edi
  0004b	75 1b		 jne	 SHORT $LN16@updatewind

; 384  :         state->wsize = 1U << state->wbits;

  0004d	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  00050	bf 01 00 00 00	 mov	 edi, 1
  00055	d3 e7		 shl	 edi, cl
  00057	89 7e 2c	 mov	 DWORD PTR [esi+44], edi

; 385  :         state->wnext = 0;

  0005a	c7 46 34 00 00
	00 00		 mov	 DWORD PTR [esi+52], 0

; 386  :         state->whave = 0;

  00061	c7 46 30 00 00
	00 00		 mov	 DWORD PTR [esi+48], 0
$LN16@updatewind:

; 387  :     }
; 388  : 
; 389  :     /* copy state->wsize or less output bytes into the circular window */
; 390  :     if (copy >= state->wsize) {

  00068	8b 5d 08	 mov	 ebx, DWORD PTR _copy$[ebp]
  0006b	3b df		 cmp	 ebx, edi
  0006d	72 23		 jb	 SHORT $LN5@updatewind

; 391  :         zmemcpy(state->window, end - state->wsize, state->wsize);

  0006f	57		 push	 edi
  00070	2b c7		 sub	 eax, edi
  00072	50		 push	 eax
  00073	52		 push	 edx
  00074	e8 00 00 00 00	 call	 _memcpy

; 392  :         state->wnext = 0;
; 393  :         state->whave = state->wsize;

  00079	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0007c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 409  :         }
; 410  :     }
; 411  :     return 0;

  0007f	89 46 30	 mov	 DWORD PTR [esi+48], eax
  00082	33 c0		 xor	 eax, eax
  00084	c7 46 34 00 00
	00 00		 mov	 DWORD PTR [esi+52], 0
  0008b	5f		 pop	 edi

; 412  : }

  0008c	5e		 pop	 esi
  0008d	5b		 pop	 ebx
  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c3		 ret	 0
$LN5@updatewind:

; 394  :     }
; 395  :     else {
; 396  :         dist = state->wsize - state->wnext;

  00092	8b 4e 34	 mov	 ecx, DWORD PTR [esi+52]
  00095	2b f9		 sub	 edi, ecx

; 397  :         if (dist > copy) dist = copy;

  00097	3b fb		 cmp	 edi, ebx
  00099	0f 47 fb	 cmova	 edi, ebx

; 398  :         zmemcpy(state->window + state->wnext, end - copy, dist);

  0009c	2b c3		 sub	 eax, ebx
  0009e	57		 push	 edi
  0009f	50		 push	 eax
  000a0	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
  000a3	50		 push	 eax
  000a4	e8 00 00 00 00	 call	 _memcpy
  000a9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 399  :         copy -= dist;

  000ac	2b df		 sub	 ebx, edi

; 400  :         if (copy) {

  000ae	74 24		 je	 SHORT $LN8@updatewind

; 401  :             zmemcpy(state->window, end - copy, copy);

  000b0	8b 45 fc	 mov	 eax, DWORD PTR _end$1$[ebp]
  000b3	53		 push	 ebx
  000b4	2b c3		 sub	 eax, ebx
  000b6	50		 push	 eax
  000b7	ff 76 38	 push	 DWORD PTR [esi+56]
  000ba	e8 00 00 00 00	 call	 _memcpy

; 402  :             state->wnext = copy;
; 403  :             state->whave = state->wsize;

  000bf	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  000c2	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c5	89 5e 34	 mov	 DWORD PTR [esi+52], ebx

; 409  :         }
; 410  :     }
; 411  :     return 0;

  000c8	89 46 30	 mov	 DWORD PTR [esi+48], eax
  000cb	33 c0		 xor	 eax, eax
  000cd	5f		 pop	 edi

; 412  : }

  000ce	5e		 pop	 esi
  000cf	5b		 pop	 ebx
  000d0	8b e5		 mov	 esp, ebp
  000d2	5d		 pop	 ebp
  000d3	c3		 ret	 0
$LN8@updatewind:

; 404  :         }
; 405  :         else {
; 406  :             state->wnext += dist;

  000d4	01 7e 34	 add	 DWORD PTR [esi+52], edi

; 407  :             if (state->wnext == state->wsize) state->wnext = 0;

  000d7	8b 4e 2c	 mov	 ecx, DWORD PTR [esi+44]
  000da	39 4e 34	 cmp	 DWORD PTR [esi+52], ecx
  000dd	75 07		 jne	 SHORT $LN10@updatewind
  000df	c7 46 34 00 00
	00 00		 mov	 DWORD PTR [esi+52], 0
$LN10@updatewind:

; 408  :             if (state->whave < state->wsize) state->whave += dist;

  000e6	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  000e9	3b c1		 cmp	 eax, ecx
  000eb	73 05		 jae	 SHORT $LN11@updatewind
  000ed	03 c7		 add	 eax, edi

; 409  :         }
; 410  :     }
; 411  :     return 0;

  000ef	89 46 30	 mov	 DWORD PTR [esi+48], eax
$LN11@updatewind:

; 412  : }

  000f2	5f		 pop	 edi
  000f3	5e		 pop	 esi
  000f4	33 c0		 xor	 eax, eax
  000f6	5b		 pop	 ebx
  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c3		 ret	 0
_updatewindow ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\Pichau\Documents\Boldergarte\Softwares\LIBRARIES\downloads\zlib\zlib-develop\zlib-develop\inflate.c
;	COMDAT _inflateGetDictionary@12
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_dictionary$ = 12					; size = 4
_dictLength$ = 16					; size = 4
_inflateGetDictionary@12 PROC				; COMDAT

; 1279 :                                  uInt *dictLength) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1280 :     struct inflate_state FAR *state;
; 1281 : 
; 1282 :     /* check state */
; 1283 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 09		 je	 SHORT $LN2@inflateGet
  0000f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1296 : }

  00014	5d		 pop	 ebp
  00015	c2 0c 00	 ret	 12			; 0000000cH
$LN2@inflateGet:
  00018	56		 push	 esi

; 1284 :     state = (struct inflate_state FAR *)strm->state;

  00019	8b 71 1c	 mov	 esi, DWORD PTR [ecx+28]

; 1285 : 
; 1286 :     /* copy dictionary */
; 1287 :     if (state->whave && dictionary != Z_NULL) {

  0001c	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0001f	85 c0		 test	 eax, eax
  00021	74 31		 je	 SHORT $LN3@inflateGet
  00023	57		 push	 edi
  00024	8b 7d 0c	 mov	 edi, DWORD PTR _dictionary$[ebp]
  00027	85 ff		 test	 edi, edi
  00029	74 28		 je	 SHORT $LN10@inflateGet

; 1288 :         zmemcpy(dictionary, state->window + state->wnext,

  0002b	2b 46 34	 sub	 eax, DWORD PTR [esi+52]
  0002e	50		 push	 eax
  0002f	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00032	03 46 34	 add	 eax, DWORD PTR [esi+52]
  00035	50		 push	 eax
  00036	57		 push	 edi
  00037	e8 00 00 00 00	 call	 _memcpy

; 1289 :                 state->whave - state->wnext);
; 1290 :         zmemcpy(dictionary + state->whave - state->wnext,

  0003c	8b 4e 34	 mov	 ecx, DWORD PTR [esi+52]
  0003f	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00042	51		 push	 ecx
  00043	ff 76 38	 push	 DWORD PTR [esi+56]
  00046	2b c1		 sub	 eax, ecx
  00048	03 c7		 add	 eax, edi
  0004a	50		 push	 eax
  0004b	e8 00 00 00 00	 call	 _memcpy
  00050	83 c4 18	 add	 esp, 24			; 00000018H
$LN10@inflateGet:
  00053	5f		 pop	 edi
$LN3@inflateGet:

; 1291 :                 state->window, state->wnext);
; 1292 :     }
; 1293 :     if (dictLength != Z_NULL)

  00054	8b 4d 10	 mov	 ecx, DWORD PTR _dictLength$[ebp]
  00057	85 c9		 test	 ecx, ecx
  00059	74 05		 je	 SHORT $LN4@inflateGet

; 1294 :         *dictLength = state->whave;

  0005b	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0005e	89 01		 mov	 DWORD PTR [ecx], eax
$LN4@inflateGet:

; 1295 :     return Z_OK;

  00060	33 c0		 xor	 eax, eax
  00062	5e		 pop	 esi

; 1296 : }

  00063	5d		 pop	 ebp
  00064	c2 0c 00	 ret	 12			; 0000000cH
_inflateGetDictionary@12 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\Pichau\Documents\Boldergarte\Softwares\LIBRARIES\downloads\zlib\zlib-develop\zlib-develop\inflate.c
;	COMDAT _inflateSetDictionary@12
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_dictionary$ = 12					; size = 4
_dictLength$ = 16					; size = 4
_inflateSetDictionary@12 PROC				; COMDAT

; 1299 :                                  uInt dictLength) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1300 :     struct inflate_state FAR *state;
; 1301 :     unsigned long dictid;
; 1302 :     int ret;
; 1303 : 
; 1304 :     /* check state */
; 1305 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _strm$[ebp]
  00007	8b cb		 mov	 ecx, ebx
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	e8 00 00 00 00	 call	 _inflateStateCheck
  00010	85 c0		 test	 eax, eax
  00012	75 7d		 jne	 SHORT $LN10@inflateSet

; 1306 :     state = (struct inflate_state FAR *)strm->state;

  00014	8b 7b 1c	 mov	 edi, DWORD PTR [ebx+28]

; 1307 :     if (state->wrap != 0 && state->mode != DICT)

  00017	39 47 0c	 cmp	 DWORD PTR [edi+12], eax
  0001a	74 09		 je	 SHORT $LN9@inflateSet
  0001c	81 7f 04 3e 3f
	00 00		 cmp	 DWORD PTR [edi+4], 16190 ; 00003f3eH
  00023	75 6c		 jne	 SHORT $LN10@inflateSet
$LN9@inflateSet:

; 1308 :         return Z_STREAM_ERROR;
; 1309 : 
; 1310 :     /* check for correct dictionary identifier */
; 1311 :     if (state->mode == DICT) {

  00025	81 7f 04 3e 3f
	00 00		 cmp	 DWORD PTR [edi+4], 16190 ; 00003f3eH
  0002c	75 28		 jne	 SHORT $LN5@inflateSet

; 1312 :         dictid = adler32(0L, Z_NULL, 0);

  0002e	6a 00		 push	 0
  00030	6a 00		 push	 0
  00032	6a 00		 push	 0
  00034	e8 00 00 00 00	 call	 _adler32@12

; 1313 :         dictid = adler32(dictid, dictionary, dictLength);

  00039	ff 75 10	 push	 DWORD PTR _dictLength$[ebp]
  0003c	ff 75 0c	 push	 DWORD PTR _dictionary$[ebp]
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 _adler32@12

; 1314 :         if (dictid != state->check)

  00045	3b 47 1c	 cmp	 eax, DWORD PTR [edi+28]
  00048	74 0c		 je	 SHORT $LN5@inflateSet

; 1328 : }

  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi
  0004c	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  00051	5b		 pop	 ebx
  00052	5d		 pop	 ebp
  00053	c2 0c 00	 ret	 12			; 0000000cH
$LN5@inflateSet:

; 1315 :             return Z_DATA_ERROR;
; 1316 :     }
; 1317 : 
; 1318 :     /* copy dictionary to window using updatewindow(), which will amend the
; 1319 :        existing dictionary if appropriate */
; 1320 :     ret = updatewindow(strm, dictionary + dictLength, dictLength);

  00056	8b 45 10	 mov	 eax, DWORD PTR _dictLength$[ebp]
  00059	8b cb		 mov	 ecx, ebx
  0005b	8b 55 0c	 mov	 edx, DWORD PTR _dictionary$[ebp]
  0005e	50		 push	 eax
  0005f	8d 14 02	 lea	 edx, DWORD PTR [edx+eax]
  00062	e8 00 00 00 00	 call	 _updatewindow
  00067	83 c4 04	 add	 esp, 4

; 1321 :     if (ret) {

  0006a	85 c0		 test	 eax, eax
  0006c	74 13		 je	 SHORT $LN6@inflateSet

; 1322 :         state->mode = MEM;

  0006e	c7 47 04 52 3f
	00 00		 mov	 DWORD PTR [edi+4], 16210 ; 00003f52H

; 1323 :         return Z_MEM_ERROR;

  00075	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  0007a	5f		 pop	 edi

; 1328 : }

  0007b	5e		 pop	 esi
  0007c	5b		 pop	 ebx
  0007d	5d		 pop	 ebp
  0007e	c2 0c 00	 ret	 12			; 0000000cH
$LN6@inflateSet:

; 1324 :     }
; 1325 :     state->havedict = 1;

  00081	c7 47 10 01 00
	00 00		 mov	 DWORD PTR [edi+16], 1

; 1326 :     Tracev((stderr, "inflate:   dictionary set\n"));
; 1327 :     return Z_OK;

  00088	33 c0		 xor	 eax, eax
  0008a	5f		 pop	 edi

; 1328 : }

  0008b	5e		 pop	 esi
  0008c	5b		 pop	 ebx
  0008d	5d		 pop	 ebp
  0008e	c2 0c 00	 ret	 12			; 0000000cH
$LN10@inflateSet:
  00091	5f		 pop	 edi
  00092	5e		 pop	 esi
  00093	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00098	5b		 pop	 ebx
  00099	5d		 pop	 ebp
  0009a	c2 0c 00	 ret	 12			; 0000000cH
_inflateSetDictionary@12 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\Pichau\Documents\Boldergarte\Softwares\LIBRARIES\downloads\zlib\zlib-develop\zlib-develop\inflate.c
;	COMDAT _inflateGetHeader@8
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_head$ = 12						; size = 4
_inflateGetHeader@8 PROC				; COMDAT

; 1330 : int ZEXPORT inflateGetHeader(z_streamp strm, gz_headerp head) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1331 :     struct inflate_state FAR *state;
; 1332 : 
; 1333 :     /* check state */
; 1334 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	75 1c		 jne	 SHORT $LN5@inflateGet

; 1335 :     state = (struct inflate_state FAR *)strm->state;

  0000f	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]

; 1336 :     if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;

  00012	f6 41 0c 02	 test	 BYTE PTR [ecx+12], 2
  00016	74 13		 je	 SHORT $LN5@inflateGet

; 1337 : 
; 1338 :     /* save header structure */
; 1339 :     state->head = head;

  00018	8b 45 0c	 mov	 eax, DWORD PTR _head$[ebp]
  0001b	89 41 24	 mov	 DWORD PTR [ecx+36], eax

; 1340 :     head->done = 0;

  0001e	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], 0

; 1341 :     return Z_OK;

  00025	33 c0		 xor	 eax, eax

; 1342 : }

  00027	5d		 pop	 ebp
  00028	c2 08 00	 ret	 8
$LN5@inflateGet:

; 1336 :     if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;

  0002b	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1342 : }

  00030	5d		 pop	 ebp
  00031	c2 08 00	 ret	 8
_inflateGetHeader@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\Pichau\Documents\Boldergarte\Softwares\LIBRARIES\downloads\zlib\zlib-develop\zlib-develop\inflate.c
;	COMDAT _syncsearch
_TEXT	SEGMENT
_buf$1$ = -8						; size = 4
_have$1$ = -4						; size = 4
_len$ = 8						; size = 4
_syncsearch PROC					; COMDAT
; _have$ = ecx
; _buf$ = edx

; 1356 :                           unsigned len) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1357 :     unsigned got;
; 1358 :     unsigned next;
; 1359 : 
; 1360 :     got = *have;

  00006	8b 01		 mov	 eax, DWORD PTR [ecx]
  00008	56		 push	 esi
  00009	57		 push	 edi

; 1361 :     next = 0;
; 1362 :     while (next < len && got < 4) {

  0000a	8b 7d 08	 mov	 edi, DWORD PTR _len$[ebp]
  0000d	33 f6		 xor	 esi, esi
  0000f	89 55 f8	 mov	 DWORD PTR _buf$1$[ebp], edx
  00012	89 4d fc	 mov	 DWORD PTR _have$1$[ebp], ecx
  00015	85 ff		 test	 edi, edi
  00017	74 50		 je	 SHORT $LN13@syncsearch
  00019	53		 push	 ebx
  0001a	66 0f 1f 44 00
	00		 npad	 6
$LL2@syncsearch:
  00020	83 f8 04	 cmp	 eax, 4
  00023	73 36		 jae	 SHORT $LN14@syncsearch

; 1363 :         if ((int)(buf[next]) == (got < 2 ? 0 : 0xff))

  00025	8a 1c 16	 mov	 bl, BYTE PTR [esi+edx]
  00028	83 f8 02	 cmp	 eax, 2
  0002b	0f b6 cb	 movzx	 ecx, bl
  0002e	1b d2		 sbb	 edx, edx
  00030	81 e2 01 ff ff
	ff		 and	 edx, -255		; ffffff01H
  00036	81 c2 ff 00 00
	00		 add	 edx, 255		; 000000ffH
  0003c	3b ca		 cmp	 ecx, edx
  0003e	75 03		 jne	 SHORT $LN4@syncsearch

; 1364 :             got++;

  00040	40		 inc	 eax
  00041	eb 10		 jmp	 SHORT $LN7@syncsearch
$LN4@syncsearch:

; 1365 :         else if (buf[next])
; 1366 :             got = 0;
; 1367 :         else
; 1368 :             got = 4 - got;

  00043	b9 04 00 00 00	 mov	 ecx, 4
  00048	33 d2		 xor	 edx, edx
  0004a	2b c8		 sub	 ecx, eax
  0004c	84 db		 test	 bl, bl
  0004e	8b c1		 mov	 eax, ecx
  00050	0f 45 c2	 cmovne	 eax, edx
$LN7@syncsearch:

; 1369 :         next++;

  00053	8b 55 f8	 mov	 edx, DWORD PTR _buf$1$[ebp]
  00056	46		 inc	 esi
  00057	3b f7		 cmp	 esi, edi
  00059	72 c5		 jb	 SHORT $LL2@syncsearch
$LN14@syncsearch:

; 1370 :     }
; 1371 :     *have = got;

  0005b	8b 4d fc	 mov	 ecx, DWORD PTR _have$1$[ebp]
  0005e	5b		 pop	 ebx
  0005f	5f		 pop	 edi
  00060	89 01		 mov	 DWORD PTR [ecx], eax

; 1372 :     return next;

  00062	8b c6		 mov	 eax, esi

; 1373 : }

  00064	5e		 pop	 esi
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
$LN13@syncsearch:

; 1370 :     }
; 1371 :     *have = got;

  00069	89 01		 mov	 DWORD PTR [ecx], eax

; 1372 :     return next;

  0006b	8b c6		 mov	 eax, esi
  0006d	5f		 pop	 edi

; 1373 : }

  0006e	5e		 pop	 esi
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
_syncsearch ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\Pichau\Documents\Boldergarte\Softwares\LIBRARIES\downloads\zlib\zlib-develop\zlib-develop\inflate.c
;	COMDAT _inflateSync@4
_TEXT	SEGMENT
_state$1$ = -12						; size = 4
tv394 = -8						; size = 4
_buf$ = -8						; size = 4
$T1 = -4						; size = 4
tv382 = 8						; size = 4
$T2 = 8							; size = 4
_strm$ = 8						; size = 4
_inflateSync@4 PROC					; COMDAT

; 1375 : int ZEXPORT inflateSync(z_streamp strm) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	8b 5d 08	 mov	 ebx, DWORD PTR _strm$[ebp]

; 1376 :     unsigned len;               /* number of bytes to look at or looked at */
; 1377 :     int flags;                  /* temporary to save header status */
; 1378 :     unsigned long in, out;      /* temporary to save total_in and total_out */
; 1379 :     unsigned char buf[4];       /* to restore bit buffer to byte string */
; 1380 :     struct inflate_state FAR *state;
; 1381 : 
; 1382 :     /* check parameters */
; 1383 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  0000a	8b cb		 mov	 ecx, ebx
  0000c	e8 00 00 00 00	 call	 _inflateStateCheck
  00011	85 c0		 test	 eax, eax
  00013	74 0c		 je	 SHORT $LN4@inflateSyn
  00015	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0001a	5b		 pop	 ebx

; 1421 : }

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
$LN4@inflateSyn:

; 1384 :     state = (struct inflate_state FAR *)strm->state;
; 1385 :     if (strm->avail_in == 0 && state->bits < 8) return Z_BUF_ERROR;

  00021	83 7b 04 00	 cmp	 DWORD PTR [ebx+4], 0
  00025	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  00028	56		 push	 esi
  00029	57		 push	 edi
  0002a	8b 7b 1c	 mov	 edi, DWORD PTR [ebx+28]
  0002d	89 7d f4	 mov	 DWORD PTR _state$1$[ebp], edi
  00030	89 45 08	 mov	 DWORD PTR $T2[ebp], eax
  00033	8d 77 40	 lea	 esi, DWORD PTR [edi+64]
  00036	89 75 fc	 mov	 DWORD PTR $T1[ebp], esi
  00039	75 13		 jne	 SHORT $LN17@inflateSyn
  0003b	83 3e 08	 cmp	 DWORD PTR [esi], 8
  0003e	73 11		 jae	 SHORT $LN14@inflateSyn
  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	b8 fb ff ff ff	 mov	 eax, -5			; fffffffbH
  00047	5b		 pop	 ebx

; 1421 : }

  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c2 04 00	 ret	 4
$LN17@inflateSyn:
  0004e	89 75 fc	 mov	 DWORD PTR $T1[ebp], esi
$LN14@inflateSyn:

; 1386 : 
; 1387 :     /* if first time, start search in bit buffer */
; 1388 :     if (state->mode != SYNC) {

  00051	81 7f 04 53 3f
	00 00		 cmp	 DWORD PTR [edi+4], 16211 ; 00003f53H
  00058	74 64		 je	 SHORT $LN18@inflateSyn

; 1389 :         state->mode = SYNC;
; 1390 :         state->hold >>= state->bits & 7;

  0005a	8b 16		 mov	 edx, DWORD PTR [esi]
  0005c	8b ca		 mov	 ecx, edx
  0005e	8b 47 3c	 mov	 eax, DWORD PTR [edi+60]
  00061	83 e1 07	 and	 ecx, 7

; 1391 :         state->bits -= state->bits & 7;

  00064	2b d1		 sub	 edx, ecx
  00066	d3 e8		 shr	 eax, cl
  00068	89 16		 mov	 DWORD PTR [esi], edx

; 1392 :         len = 0;

  0006a	8d 4b 04	 lea	 ecx, DWORD PTR [ebx+4]
  0006d	33 f6		 xor	 esi, esi
  0006f	c7 47 04 53 3f
	00 00		 mov	 DWORD PTR [edi+4], 16211 ; 00003f53H
  00076	89 45 f8	 mov	 DWORD PTR tv394[ebp], eax
  00079	89 47 3c	 mov	 DWORD PTR [edi+60], eax
  0007c	89 4d 08	 mov	 DWORD PTR $T2[ebp], ecx

; 1393 :         while (state->bits >= 8) {

  0007f	83 fa 08	 cmp	 edx, 8
  00082	72 22		 jb	 SHORT $LN3@inflateSyn
  00084	8b c8		 mov	 ecx, eax
$LL2@inflateSyn:

; 1394 :             buf[len++] = (unsigned char)(state->hold);

  00086	88 4c 35 f8	 mov	 BYTE PTR _buf$[ebp+esi], cl

; 1395 :             state->hold >>= 8;
; 1396 :             state->bits -= 8;

  0008a	83 ea 08	 sub	 edx, 8
  0008d	c1 e8 08	 shr	 eax, 8
  00090	46		 inc	 esi
  00091	8a c8		 mov	 cl, al
  00093	83 fa 08	 cmp	 edx, 8
  00096	73 ee		 jae	 SHORT $LL2@inflateSyn
  00098	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  0009b	89 47 3c	 mov	 DWORD PTR [edi+60], eax
  0009e	89 11		 mov	 DWORD PTR [ecx], edx
  000a0	8d 4b 04	 lea	 ecx, DWORD PTR [ebx+4]
  000a3	89 4d 08	 mov	 DWORD PTR $T2[ebp], ecx
$LN3@inflateSyn:

; 1397 :         }
; 1398 :         state->have = 0;

  000a6	8d 4f 6c	 lea	 ecx, DWORD PTR [edi+108]

; 1399 :         syncsearch(&(state->have), buf, len);

  000a9	8d 55 f8	 lea	 edx, DWORD PTR _buf$[ebp]
  000ac	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  000b2	56		 push	 esi
  000b3	e8 00 00 00 00	 call	 _syncsearch
  000b8	8b 45 08	 mov	 eax, DWORD PTR $T2[ebp]
  000bb	83 c4 04	 add	 esp, 4
$LN18@inflateSyn:

; 1400 :     }
; 1401 : 
; 1402 :     /* search available input */
; 1403 :     len = syncsearch(&(state->have), strm->next_in, strm->avail_in);

  000be	ff 30		 push	 DWORD PTR [eax]
  000c0	8b 13		 mov	 edx, DWORD PTR [ebx]
  000c2	8d 4f 6c	 lea	 ecx, DWORD PTR [edi+108]
  000c5	e8 00 00 00 00	 call	 _syncsearch

; 1404 :     strm->avail_in -= len;

  000ca	8b 4d 08	 mov	 ecx, DWORD PTR $T2[ebp]
  000cd	83 c4 04	 add	 esp, 4

; 1405 :     strm->next_in += len;

  000d0	01 03		 add	 DWORD PTR [ebx], eax

; 1406 :     strm->total_in += len;

  000d2	01 43 08	 add	 DWORD PTR [ebx+8], eax
  000d5	29 01		 sub	 DWORD PTR [ecx], eax

; 1407 : 
; 1408 :     /* return no joy or set up to restart inflate() on a new block */
; 1409 :     if (state->have != 4) return Z_DATA_ERROR;

  000d7	83 7f 6c 04	 cmp	 DWORD PTR [edi+108], 4
  000db	74 0e		 je	 SHORT $LN7@inflateSyn
  000dd	5f		 pop	 edi
  000de	5e		 pop	 esi
  000df	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  000e4	5b		 pop	 ebx

; 1421 : }

  000e5	8b e5		 mov	 esp, ebp
  000e7	5d		 pop	 ebp
  000e8	c2 04 00	 ret	 4
$LN7@inflateSyn:

; 1410 :     if (state->flags == -1)

  000eb	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  000ee	89 45 08	 mov	 DWORD PTR tv382[ebp], eax
  000f1	83 f8 ff	 cmp	 eax, -1
  000f4	75 09		 jne	 SHORT $LN8@inflateSyn

; 1411 :         state->wrap = 0;    /* if no header yet, treat as raw */

  000f6	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0
  000fd	eb 04		 jmp	 SHORT $LN9@inflateSyn
$LN8@inflateSyn:

; 1412 :     else
; 1413 :         state->wrap &= ~4;  /* no point in computing a check value now */

  000ff	83 67 0c fb	 and	 DWORD PTR [edi+12], -5	; fffffffbH
$LN9@inflateSyn:

; 1414 :     flags = state->flags;
; 1415 :     in = strm->total_in;  out = strm->total_out;

  00103	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]
  00106	8b 73 14	 mov	 esi, DWORD PTR [ebx+20]

; 1416 :     inflateReset(strm);

  00109	53		 push	 ebx
  0010a	e8 00 00 00 00	 call	 _inflateReset@4

; 1417 :     strm->total_in = in;  strm->total_out = out;
; 1418 :     state->flags = flags;

  0010f	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  00112	8b 4d 08	 mov	 ecx, DWORD PTR tv382[ebp]
  00115	89 7b 08	 mov	 DWORD PTR [ebx+8], edi
  00118	89 73 14	 mov	 DWORD PTR [ebx+20], esi
  0011b	5f		 pop	 edi
  0011c	5e		 pop	 esi
  0011d	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 1419 :     state->mode = TYPE;

  00120	c7 40 04 3f 3f
	00 00		 mov	 DWORD PTR [eax+4], 16191 ; 00003f3fH

; 1420 :     return Z_OK;

  00127	33 c0		 xor	 eax, eax
  00129	5b		 pop	 ebx

; 1421 : }

  0012a	8b e5		 mov	 esp, ebp
  0012c	5d		 pop	 ebp
  0012d	c2 04 00	 ret	 4
_inflateSync@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\Pichau\Documents\Boldergarte\Softwares\LIBRARIES\downloads\zlib\zlib-develop\zlib-develop\inflate.c
;	COMDAT _inflateSyncPoint@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateSyncPoint@4 PROC				; COMDAT

; 1431 : int ZEXPORT inflateSyncPoint(z_streamp strm) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1432 :     struct inflate_state FAR *state;
; 1433 : 
; 1434 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 09		 je	 SHORT $LN2@inflateSyn
  0000f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1437 : }

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
$LN2@inflateSyn:

; 1435 :     state = (struct inflate_state FAR *)strm->state;

  00018	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]

; 1436 :     return state->mode == STORED && state->bits == 0;

  0001b	81 78 04 41 3f
	00 00		 cmp	 DWORD PTR [eax+4], 16193 ; 00003f41H
  00022	75 0f		 jne	 SHORT $LN4@inflateSyn
  00024	83 78 40 00	 cmp	 DWORD PTR [eax+64], 0
  00028	75 09		 jne	 SHORT $LN4@inflateSyn
  0002a	b8 01 00 00 00	 mov	 eax, 1

; 1437 : }

  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
$LN4@inflateSyn:

; 1436 :     return state->mode == STORED && state->bits == 0;

  00033	33 c0		 xor	 eax, eax

; 1437 : }

  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
_inflateSyncPoint@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\Pichau\Documents\Boldergarte\Softwares\LIBRARIES\downloads\zlib\zlib-develop\zlib-develop\inflate.c
;	COMDAT _inflateCopy@8
_TEXT	SEGMENT
$T1 = -4						; size = 4
_dest$ = 8						; size = 4
_window$1$ = 12						; size = 4
_source$ = 12						; size = 4
_inflateCopy@8 PROC					; COMDAT

; 1439 : int ZEXPORT inflateCopy(z_streamp dest, z_streamp source) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	57		 push	 edi

; 1440 :     struct inflate_state FAR *state;
; 1441 :     struct inflate_state FAR *copy;
; 1442 :     unsigned char FAR *window;
; 1443 :     unsigned wsize;
; 1444 : 
; 1445 :     /* check input */
; 1446 :     if (inflateStateCheck(source) || dest == Z_NULL)

  00005	8b 7d 0c	 mov	 edi, DWORD PTR _source$[ebp]
  00008	8b cf		 mov	 ecx, edi
  0000a	e8 00 00 00 00	 call	 _inflateStateCheck
  0000f	85 c0		 test	 eax, eax
  00011	0f 85 3c 01 00
	00		 jne	 $LN3@inflateCop
  00017	39 45 08	 cmp	 DWORD PTR _dest$[ebp], eax
  0001a	0f 84 33 01 00
	00		 je	 $LN3@inflateCop

; 1448 :     state = (struct inflate_state FAR *)source->state;
; 1449 : 
; 1450 :     /* allocate space */
; 1451 :     copy = (struct inflate_state FAR *)

  00020	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  00023	53		 push	 ebx
  00024	8b 5f 1c	 mov	 ebx, DWORD PTR [edi+28]
  00027	56		 push	 esi
  00028	68 d0 1b 00 00	 push	 7120			; 00001bd0H
  0002d	6a 01		 push	 1
  0002f	ff 77 28	 push	 DWORD PTR [edi+40]
  00032	ff d0		 call	 eax
  00034	8b f0		 mov	 esi, eax
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1452 :            ZALLOC(source, 1, sizeof(struct inflate_state));
; 1453 :     if (copy == Z_NULL) return Z_MEM_ERROR;

  00039	85 f6		 test	 esi, esi
  0003b	74 3d		 je	 SHORT $LN23@inflateCop

; 1454 :     window = Z_NULL;
; 1455 :     if (state->window != Z_NULL) {

  0003d	83 7b 38 00	 cmp	 DWORD PTR [ebx+56], 0
  00041	8d 4b 28	 lea	 ecx, DWORD PTR [ebx+40]
  00044	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _window$1$[ebp], 0
  0004b	89 4d fc	 mov	 DWORD PTR $T1[ebp], ecx
  0004e	74 38		 je	 SHORT $LN11@inflateCop

; 1456 :         window = (unsigned char FAR *)

  00050	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00052	b8 01 00 00 00	 mov	 eax, 1
  00057	d3 e0		 shl	 eax, cl
  00059	6a 01		 push	 1
  0005b	50		 push	 eax
  0005c	ff 77 28	 push	 DWORD PTR [edi+40]
  0005f	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  00062	ff d0		 call	 eax
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH
  00067	89 45 0c	 mov	 DWORD PTR _window$1$[ebp], eax

; 1457 :                  ZALLOC(source, 1U << state->wbits, sizeof(unsigned char));
; 1458 :         if (window == Z_NULL) {

  0006a	85 c0		 test	 eax, eax
  0006c	75 1d		 jne	 SHORT $LN12@inflateCop

; 1459 :             ZFREE(source, copy);

  0006e	8b 47 24	 mov	 eax, DWORD PTR [edi+36]
  00071	56		 push	 esi
  00072	ff 77 28	 push	 DWORD PTR [edi+40]
  00075	ff d0		 call	 eax
  00077	83 c4 08	 add	 esp, 8
$LN23@inflateCop:

; 1460 :             return Z_MEM_ERROR;

  0007a	5e		 pop	 esi
  0007b	5b		 pop	 ebx
  0007c	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  00081	5f		 pop	 edi

; 1481 : }

  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c2 08 00	 ret	 8
$LN11@inflateCop:
  00088	89 4d fc	 mov	 DWORD PTR $T1[ebp], ecx
$LN12@inflateCop:

; 1461 :         }
; 1462 :     }
; 1463 : 
; 1464 :     /* copy state */
; 1465 :     zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));

  0008b	0f 10 07	 movups	 xmm0, XMMWORD PTR [edi]
  0008e	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]

; 1466 :     zmemcpy((voidpf)copy, (voidpf)state, sizeof(struct inflate_state));

  00091	68 d0 1b 00 00	 push	 7120			; 00001bd0H
  00096	53		 push	 ebx
  00097	56		 push	 esi
  00098	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
  0009b	0f 10 47 10	 movups	 xmm0, XMMWORD PTR [edi+16]
  0009f	0f 11 40 10	 movups	 XMMWORD PTR [eax+16], xmm0
  000a3	0f 10 47 20	 movups	 xmm0, XMMWORD PTR [edi+32]
  000a7	0f 11 40 20	 movups	 XMMWORD PTR [eax+32], xmm0
  000ab	f3 0f 7e 47 30	 movq	 xmm0, QWORD PTR [edi+48]
  000b0	66 0f d6 40 30	 movq	 QWORD PTR [eax+48], xmm0
  000b5	e8 00 00 00 00	 call	 _memcpy

; 1467 :     copy->strm = dest;

  000ba	8b 7d 08	 mov	 edi, DWORD PTR _dest$[ebp]

; 1468 :     if (state->lencode >= state->codes &&

  000bd	8d 83 34 05 00
	00		 lea	 eax, DWORD PTR [ebx+1332]
  000c3	89 3e		 mov	 DWORD PTR [esi], edi
  000c5	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c8	8b 4b 50	 mov	 ecx, DWORD PTR [ebx+80]
  000cb	3b c8		 cmp	 ecx, eax
  000cd	72 38		 jb	 SHORT $LN7@inflateCop
  000cf	8d 83 c0 1b 00
	00		 lea	 eax, DWORD PTR [ebx+7104]
  000d5	3b c8		 cmp	 ecx, eax
  000d7	77 2e		 ja	 SHORT $LN7@inflateCop

; 1469 :         state->lencode <= state->codes + ENOUGH - 1) {
; 1470 :         copy->lencode = copy->codes + (state->lencode - state->codes);

  000d9	2b cb		 sub	 ecx, ebx
  000db	8d 81 cc fa ff
	ff		 lea	 eax, DWORD PTR [ecx-1332]
  000e1	c1 f8 02	 sar	 eax, 2
  000e4	05 4d 01 00 00	 add	 eax, 333		; 0000014dH
  000e9	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  000ec	89 46 50	 mov	 DWORD PTR [esi+80], eax

; 1471 :         copy->distcode = copy->codes + (state->distcode - state->codes);

  000ef	8b 43 54	 mov	 eax, DWORD PTR [ebx+84]
  000f2	2b c3		 sub	 eax, ebx
  000f4	2d 34 05 00 00	 sub	 eax, 1332		; 00000534H
  000f9	c1 f8 02	 sar	 eax, 2
  000fc	05 4d 01 00 00	 add	 eax, 333		; 0000014dH
  00101	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  00104	89 46 54	 mov	 DWORD PTR [esi+84], eax
$LN7@inflateCop:

; 1472 :     }
; 1473 :     copy->next = copy->codes + (state->next - state->codes);

  00107	8b 43 70	 mov	 eax, DWORD PTR [ebx+112]
  0010a	2b c3		 sub	 eax, ebx
  0010c	2d 34 05 00 00	 sub	 eax, 1332		; 00000534H
  00111	c1 f8 02	 sar	 eax, 2
  00114	05 4d 01 00 00	 add	 eax, 333		; 0000014dH
  00119	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  0011c	89 46 70	 mov	 DWORD PTR [esi+112], eax

; 1474 :     if (window != Z_NULL) {

  0011f	8b 45 0c	 mov	 eax, DWORD PTR _window$1$[ebp]
  00122	85 c0		 test	 eax, eax
  00124	74 1c		 je	 SHORT $LN8@inflateCop

; 1475 :         wsize = 1U << state->wbits;

  00126	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  00129	ba 01 00 00 00	 mov	 edx, 1
  0012e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00130	d3 e2		 shl	 edx, cl

; 1476 :         zmemcpy(window, state->window, wsize);

  00132	52		 push	 edx
  00133	ff 73 38	 push	 DWORD PTR [ebx+56]
  00136	50		 push	 eax
  00137	e8 00 00 00 00	 call	 _memcpy
  0013c	8b 45 0c	 mov	 eax, DWORD PTR _window$1$[ebp]
  0013f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@inflateCop:

; 1477 :     }
; 1478 :     copy->window = window;

  00142	89 46 38	 mov	 DWORD PTR [esi+56], eax

; 1479 :     dest->state = (struct internal_state FAR *)copy;
; 1480 :     return Z_OK;

  00145	33 c0		 xor	 eax, eax
  00147	89 77 1c	 mov	 DWORD PTR [edi+28], esi
  0014a	5e		 pop	 esi
  0014b	5b		 pop	 ebx
  0014c	5f		 pop	 edi

; 1481 : }

  0014d	8b e5		 mov	 esp, ebp
  0014f	5d		 pop	 ebp
  00150	c2 08 00	 ret	 8
$LN3@inflateCop:

; 1447 :         return Z_STREAM_ERROR;

  00153	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00158	5f		 pop	 edi

; 1481 : }

  00159	8b e5		 mov	 esp, ebp
  0015b	5d		 pop	 ebp
  0015c	c2 08 00	 ret	 8
_inflateCopy@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\Pichau\Documents\Boldergarte\Softwares\LIBRARIES\downloads\zlib\zlib-develop\zlib-develop\inflate.c
;	COMDAT _inflateUndermine@8
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_subvert$ = 12						; size = 4
_inflateUndermine@8 PROC				; COMDAT

; 1483 : int ZEXPORT inflateUndermine(z_streamp strm, int subvert) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1484 :     struct inflate_state FAR *state;
; 1485 : 
; 1486 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 09		 je	 SHORT $LN2@inflateUnd
  0000f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1495 : #endif
; 1496 : }

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
$LN2@inflateUnd:

; 1487 :     state = (struct inflate_state FAR *)strm->state;
; 1488 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1489 :     state->sane = !subvert;
; 1490 :     return Z_OK;
; 1491 : #else
; 1492 :     (void)subvert;
; 1493 :     state->sane = 1;

  00018	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  0001b	c7 80 c4 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+7108], 1

; 1494 :     return Z_DATA_ERROR;

  00025	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH

; 1495 : #endif
; 1496 : }

  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8
_inflateUndermine@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\Pichau\Documents\Boldergarte\Softwares\LIBRARIES\downloads\zlib\zlib-develop\zlib-develop\inflate.c
;	COMDAT _inflateValidate@8
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_check$ = 12						; size = 4
_inflateValidate@8 PROC					; COMDAT

; 1498 : int ZEXPORT inflateValidate(z_streamp strm, int check) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1499 :     struct inflate_state FAR *state;
; 1500 : 
; 1501 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 09		 je	 SHORT $LN2@inflateVal
  0000f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1508 : }

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
$LN2@inflateVal:

; 1502 :     state = (struct inflate_state FAR *)strm->state;
; 1503 :     if (check && state->wrap)

  00018	83 7d 0c 00	 cmp	 DWORD PTR _check$[ebp], 0
  0001c	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  0001f	74 13		 je	 SHORT $LN7@inflateVal
  00021	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00024	85 c9		 test	 ecx, ecx
  00026	74 0c		 je	 SHORT $LN7@inflateVal

; 1504 :         state->wrap |= 4;

  00028	83 c9 04	 or	 ecx, 4
  0002b	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 1507 :     return Z_OK;

  0002e	33 c0		 xor	 eax, eax

; 1508 : }

  00030	5d		 pop	 ebp
  00031	c2 08 00	 ret	 8
$LN7@inflateVal:

; 1505 :     else
; 1506 :         state->wrap &= ~4;

  00034	83 60 0c fb	 and	 DWORD PTR [eax+12], -5	; fffffffbH

; 1507 :     return Z_OK;

  00038	33 c0		 xor	 eax, eax

; 1508 : }

  0003a	5d		 pop	 ebp
  0003b	c2 08 00	 ret	 8
_inflateValidate@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\Pichau\Documents\Boldergarte\Softwares\LIBRARIES\downloads\zlib\zlib-develop\zlib-develop\inflate.c
;	COMDAT _inflateMark@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateMark@4 PROC					; COMDAT

; 1510 : long ZEXPORT inflateMark(z_streamp strm) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1511 :     struct inflate_state FAR *state;
; 1512 : 
; 1513 :     if (inflateStateCheck(strm))

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 09		 je	 SHORT $LN2@inflateMar

; 1514 :         return -(1L << 16);

  0000f	b8 00 00 ff ff	 mov	 eax, -65536		; ffff0000H

; 1517 :         (state->mode == COPY ? state->length :
; 1518 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1519 : }

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
$LN2@inflateMar:

; 1515 :     state = (struct inflate_state FAR *)strm->state;

  00018	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]

; 1516 :     return (long)(((unsigned long)((long)state->back)) << 16) +

  0001b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001e	81 f9 43 3f 00
	00		 cmp	 ecx, 16195		; 00003f43H
  00024	75 12		 jne	 SHORT $LN6@inflateMar
  00026	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  00029	8b 80 c8 1b 00
	00		 mov	 eax, DWORD PTR [eax+7112]
  0002f	c1 e0 10	 shl	 eax, 16			; 00000010H
  00032	03 c1		 add	 eax, ecx

; 1517 :         (state->mode == COPY ? state->length :
; 1518 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1519 : }

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
$LN6@inflateMar:

; 1516 :     return (long)(((unsigned long)((long)state->back)) << 16) +

  00038	81 f9 4c 3f 00
	00		 cmp	 ecx, 16204		; 00003f4cH
  0003e	75 18		 jne	 SHORT $LN4@inflateMar
  00040	8b 88 cc 1b 00
	00		 mov	 ecx, DWORD PTR [eax+7116]
  00046	2b 48 44	 sub	 ecx, DWORD PTR [eax+68]
  00049	8b 80 c8 1b 00
	00		 mov	 eax, DWORD PTR [eax+7112]
  0004f	c1 e0 10	 shl	 eax, 16			; 00000010H
  00052	03 c1		 add	 eax, ecx

; 1517 :         (state->mode == COPY ? state->length :
; 1518 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1519 : }

  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
$LN4@inflateMar:

; 1516 :     return (long)(((unsigned long)((long)state->back)) << 16) +

  00058	8b 80 c8 1b 00
	00		 mov	 eax, DWORD PTR [eax+7112]
  0005e	33 c9		 xor	 ecx, ecx
  00060	c1 e0 10	 shl	 eax, 16			; 00000010H
  00063	03 c1		 add	 eax, ecx

; 1517 :         (state->mode == COPY ? state->length :
; 1518 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1519 : }

  00065	5d		 pop	 ebp
  00066	c2 04 00	 ret	 4
_inflateMark@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\Pichau\Documents\Boldergarte\Softwares\LIBRARIES\downloads\zlib\zlib-develop\zlib-develop\inflate.c
;	COMDAT _inflateCodesUsed@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateCodesUsed@4 PROC				; COMDAT

; 1521 : unsigned long ZEXPORT inflateCodesUsed(z_streamp strm) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1522 :     struct inflate_state FAR *state;
; 1523 :     if (inflateStateCheck(strm)) return (unsigned long)-1;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 07		 je	 SHORT $LN2@inflateCod
  0000f	83 c8 ff	 or	 eax, -1

; 1526 : }

  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
$LN2@inflateCod:

; 1524 :     state = (struct inflate_state FAR *)strm->state;

  00016	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]

; 1525 :     return (unsigned long)(state->next - state->codes);

  00019	8b 41 70	 mov	 eax, DWORD PTR [ecx+112]
  0001c	2b c1		 sub	 eax, ecx
  0001e	2d 34 05 00 00	 sub	 eax, 1332		; 00000534H
  00023	c1 f8 02	 sar	 eax, 2

; 1526 : }

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
_inflateCodesUsed@4 ENDP
_TEXT	ENDS
END
